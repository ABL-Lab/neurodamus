/*****************************************************************
    FileName    : Map.hoc
    Project     : Blue Brain Project
    Place       : EPFL, Lausanne Switzerland.
    Purpose     : Generic associative container
    Author      : 1. James King
                  2. Rajnish Ranjan
    Revision    : $Revision$ at: $Date$ by $Author$
****************************************************************/

/*!
 * Generic associative container to allow field names to be mapped to values (stored in objects)
 * for simplicity, this is not using any sorting or binary searching.  We should at least do a check
 * for duplicate items (someday...)
 */
begintemplate Map

//------------------------------------------------------------------------------------------------------------
// Member fields
//------------------------------------------------------------------------------------------------------------

objref stringList, valueList

//------------------------------------------------------------------------------------------------------------
// Public accessible
//------------------------------------------------------------------------------------------------------------

public init, get, put, key, o, object, count, getV, valueOf

//------------------------------------------------------------------------------------------------------------
// Member function implementations
//------------------------------------------------------------------------------------------------------------

proc init() {
    stringList = new List()
    valueList = new List()
}

//------------------------------------------------------------------------------------------------------------

/*!
 * @return The number of elements in the map
 */
func count() {
    return stringList.count()
}

//------------------------------------------------------------------------------------------------------------

/*!
 * @param $1 index The index into the map from where to get a key
 * @return The string used as a key at the specified index (no bounds checking)
 */
obfunc key() {
    return stringList.o($1)
}

//------------------------------------------------------------------------------------------------------------

/*!
 * also see 'object' below
 * @param $1 index The index into the map from where to get an object
 * @return The element at the specified index (no bounds checking)
 */
obfunc o() {
    return valueList.o($1)
}

//------------------------------------------------------------------------------------------------------------

/*!
 * also see 'o' above
 * @param $1 index The index into the map from where to get an object
 * @return The element at the specified index (no bounds checking)
 */
obfunc object() {
    return valueList.o($1)
}

//------------------------------------------------------------------------------------------------------------

/*!
 * Temporary 'verbose' function for retrieving a value associated with a given name.  useful for debugging
 *
 * @param $s1/$o1 name of object to find
 * @return value of object found or NULLobject if no name found
 */
obfunc getV() { local mapIndex localobj nil
    //TODO: if we upgrade: objects should be stored sorted and then find via binary search
    
    strdef searchName
    if( argtype(1) == 0 ) {
        sprint( searchName, "%d", $1 )
    } else if( argtype(1) == 1 ) { //extract string
        searchName = $o1.s
    } else {
        searchName = $s1
    }
    
    print "look for ", searchName
    
    //iterate over list until we find a name that matches
    for mapIndex=0, stringList.count()-1 {
        print stringList.o(mapIndex).s, " vs ", searchName
        //print mapIndex, " ", stringList.o(mapIndex).s
        if( strcmp( stringList.o(mapIndex).s, searchName ) == 0 ) {
            //print "    found at index ", mapIndex, "!"
            return valueList.o(mapIndex)
        }
    }
    
    return nil
}

//------------------------------------------------------------------------------------------------------------

/*!
 * Retrieve value associated with a given name
 *
 * @param $s1/$o1 name of object to find
 * @return value of object found or NULLobject if no name found
 */
obfunc get() { local mapIndex localobj nil
    //TODO: if we upgrade: objects should be stored sorted and then find via binary search
    
    strdef searchName
    if( argtype(1) == 0 ) {
        sprint( searchName, "%d", $1 )
    } else if( argtype(1) == 1 ) { //extract string
        searchName = $o1.s
    } else {
        searchName = $s1
    }
    
    //print "look for ", searchName
    
    //iterate over list until we find a name that matches
    for mapIndex=0, stringList.count()-1 {
        //print mapIndex, " ", stringList.o(mapIndex).s
        if( strcmp( stringList.o(mapIndex).s, searchName ) == 0 ) {
            //print "    found at index ", mapIndex, "!"
            return valueList.o(mapIndex)
        }
    }
    
    return nil
}

//------------------------------------------------------------------------------------------------------------

/*!
 * Add new name/value pair to map
 *
 * @param $o1/$s1 Name used to identify pair
 * @param $o2 Object containing value to associate with given name
 */
proc put() { localobj wrapString
    //TODO: if we upgrade: check for duplicates and store new objects in lexographical order
    
    if( argtype(1) == 0 ) {
        wrapString = new String()
        sprint( wrapString.s, "%d", $1 )
        stringList.append( wrapString )
    } else if( argtype(1) == 2 ) {  //must wrap string in object
        wrapString = new String($s1)
        stringList.append( wrapString )
    } else {  
        stringList.append( new String($o1.s) ) //so as not to store a reference which might change
    }
    
    valueList.append( $o2 )
}

//------------------------------------------------------------------------------------------------------------

/*!
 * Convenience function to get a value from a Map associated with a given key and put it in a hoc primitive
 *
 * $s1 Field name - i.e. map key
 * @return Value corresponding to the key
 */
func valueOf() { local tvalue  localobj tfield
    tfield = get( $s1 )
    sscanf( tfield.s, "%lf", &tvalue )
    return tvalue
}

endtemplate Map
