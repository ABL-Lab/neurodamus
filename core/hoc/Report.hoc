/*****************************************************************
    FileName    : Report.hoc
    Project     : Blue Brain Project
    Place       : EPFL, Lausanne Switzerland.
    Purpose     : Gather data references for sending information to files
    Author      : 1. Jim King
                  2. Rajnish Ranjan
    Revision    : $Revision: 580 $ at: $Date: 2009-10-23 14:17:03 +0200 (Fri, 23 Oct 2009) $ by $Author: king $
****************************************************************/

objref globrec

begintemplate Report

//-----------------------------------------------------------------------------------------------
// Declare member variables
//-----------------------------------------------------------------------------------------------

strdef reportName, reportType,  reportOn, unit, format, outputDir
objref strobj, this, binList, rec, ALUList, ALUhelper, yvec, tvec, memory_report

external cvode

//-----------------------------------------------------------------------------------------------
// public members
//-----------------------------------------------------------------------------------------------

public init, addCompartmentReport, addSummationReport, get_memory_report

//-----------------------------------------------------------------------------------------------
// Member function implementations
//-----------------------------------------------------------------------------------------------

/*!
 * Constructor - creates report object with given parameters, will add targets/cells/points later
 *
 * @param $s1 reportName - used to either name report file or dataset within the file
 * @param $s2 type of report - support for compartment and summation
 * @param $s3 reportOn - which variable(s) to address in the targeted items
 * @param $s4 unit - unit label to stamp in report header
 * @param $s5 format - whether report is written in ASCII, HDF5, or Bin
 * @param $6 Dt - time length between reporting intervals
 * @param $7 startTime - when the report begins
 * @param $8 endTime - when the report stops
 * @param $s9 Output dir - directory where report files are to be written
 */
proc init() {
    reportName = $s1
    reportType = $s2
    reportOn = $s3
    unit = $s4
    format = $s5
    
    reportDt = $6
    startTime = $7
    endTime = $8
    
    outputDir = $s9
    
    //variables to hold section counts for the active cell, to be output as extra mapping
    nAll= 0
    nSoma = 0
    nAxon = 0
    nBasal = 0
    nApic = 0
    
    //share one StringFunctions obj for access to substr function
    strobj = new StringFunctions()
    
    //note that any BinReports need to be kept unlike ASCII and HDF5 which are stored in the cell
    binList = new List()
    
    //variable used to catch return values from functions
    retVal = 0
    
    //For summation reports, we will need to store the ALU objects that are performing operations on the various current sources
    if( strcmp( reportType, "Summation" ) == 0 ) {
        ALUList = new List()
    }
}

//-----------------------------------------------------------------------------------------------

/*!
 * Determine the absolute index of a section within the cell
 *
 * @param $o1 Cell object who owns the currently accessed section 
 * @return index which can be used to map back onto the neuron
 */
func sectionNo() { local baseOffset, secIndex  localobj str
    strdef subset
    str = new String()
    
    if( strobj.substr( secname(), "soma" ) > 0 ) {
        subset = "soma"
        baseOffset = 0
    } else if (strobj.substr( secname(), "axon") >0) {
        subset = "axon"
        baseOffset = $o1.nSecSoma
    }else if (strobj.substr( secname(), "dend") >0) {
        subset = "dend"
        baseOffset = $o1.nSecSoma + $o1.nSecAxonalOrig
    }else if (strobj.substr( secname(), "apic") > 0) {
        subset = "apic"
        baseOffset = $o1.nSecSoma + $o1.nSecAxonalOrig + $o1.nSecBasal
    }
    
    // parse out the index from the secname
    strobj.tail( secname(), subset, str.s )
    if (strobj.len(str.s) > 0) {
        strobj.left(str.s, strobj.len(str.s)-1) // result should look like [n
        strobj.right(str.s, 1)
        sscanf( str.s, "%d", &secIndex )
    } else {
        print "should this ever happen?"
    }
    
    return baseOffset + secIndex
}

//-----------------------------------------------------------------------------------------------

/*!
 * Utility function to get the section number for use in mapping the report, while also incrementing
 * a count tracking how many of each section types have been evaluated so far.  Prior to calling this function,
 * the currently accessed section should be set as when using the TPointList each_point function
 *
 * $o1 ptList
 */
proc sumSectionCounts() { local offset, x  localobj prevSection, nil
    nAll = nSoma = nAxon = nBasal = nApical = 0
    
    for $o1.each_point(&x) {
        
        // Have we moved to a new/different section?  reset prevSection
        if( object_id(prevSection) ) {
            if( !prevSection.is_cas() ) {
                prevSection = nil
            }
        }
        
        //if prevSection is unset, we need to examine the section and increment the apprpriate counter
        if( !object_id(prevSection) ) {
            
            //remeber this section for upcoming iterations
            prevSection = new SectionRef()
            
            // increment appropriate subset counter
            if( strobj.substr( secname(), "soma" ) > 0 ) {
                nSoma = nSoma+1
            } else if (strobj.substr( secname(), "axon") >0) {
                nAxon   = nAxon + 1
            }else if (strobj.substr( secname(), "dend") >0) {
                nBasal  = nBasal+ 1
            }else if (strobj.substr( secname(), "apic") > 0) {
                nApical = nApical + 1
            }
        }
    }
    
    nAll = nSoma + nAxon + nBasal + nApical
}

//-----------------------------------------------------------------------------------------------

/*!
 * Utility function to prepare a report for information about the cell such as section counts (i.e. extra mapping)
 * In additon, retrieves the ASCII or HDF5 report object from a cell object, encapsulating the creation of one
 * in the event provided that this is the first request for either.  
 *
 * @param $o1 cellObj
 * @param $o2 TPointList with the points for a single cell
 * @param $3 vgid of cell (may be same as cells nomal gid)
 * @return Reference to the appropriate report object
 */
func prepareReportForCell() { local node, rpt, vgid
    strdef strCellName, tstr
    node = 0  //do we really need to know which node produced these reports?  We're trying to make this agnostic to multiple cpu
    vgid = $3
    
    sprint( strCellName, "a%d", $o1.gid )
    
    if( 0 == strcmp( format, "Bin")) {
        rpt = -1
        rec = new BinReport( 0.5, reportName, strCellName, outputDir, $o1.gid, vgid, startTime, endTime, reportDt, 1, "compartment", 5, unit )
        binList.append( rec )
    } else {
        if(0 == strcmp( format, "HDF5")) {
            if(object_id($o1.HDF5rpt, 1) < 0) {
                $o1.HDF5rpt = new HDF5Record( 0.5, node, outputDir, strCellName )
            }
            rec = $o1.HDF5rpt
        } else if( 0 == strcmp( format, "ASCII") ) {
            if(object_id($o1.ASCIIrpt, 1) < 0){
                $o1.ASCIIrpt = new ASCIIRecord( 0.5, node, outputDir, strCellName )
            }
            rec = $o1.ASCIIrpt
        } else {
            return 0
        }
        rpt = rec.newReport(strCellName, reportName, $o2.count(), startTime, endTime, reportDt, unit )
    }
        
    //get section counts: nSoma, nApic, etc
    sumSectionCounts( $o2 )

    //for ascii/hdf5 reports, must give section counts now to allocate memory - can I give it to Bin reports, too?
    if( 0 != strcmp( format, "Bin")) {
        rec.newMapping(rpt, "compartment", nAll, nSoma, nAxon, nBasal, nApical)
    } else {
        rec.ExtraMapping( nAll, nSoma, nAxon, nBasal, nApical)
    }
    
    return rpt
}

//-----------------------------------------------------------------------------------------------

/*!
 * Generate a report for cell data -> called one cell at a time so that the manager can handle things like bgid vs vgid
 *
 * @param $o1 Cell The cell getting reported
 * @param $o2 TPointList with the points for a single cell
 * @param $3 vgid Optional argument for the split cell case; the virtual gid which may be different than the normal gid (bgid)
 */
proc addCompartmentReport() { local x, rpt, vgid
    
    // Don't attempt to put a cell with 0 points in a BinReport; bad things happen
    if( $o2.count() == 0 ) {
        return
    }

    //if no $3, use cell's gid
    if( numarg() == 3 ) {
        vgid = $3
    } else {
        vgid = $o1.gid
    }
        
    rpt = prepareReportForCell( $o1, $o2, vgid )
    
    /*
     * define timesteps in tvec does not work, maybe a neuron issue
    // for the in memory report:
    tvec = new Vector()
    tvec.indgen(startTime, endTime, reportDt)
    */
    tvec = new Vector()
    memory_report = new List()
    memory_report.append(tvec)

    //for each point, register variable and mapping
    for $o2.each_point(&x) {
    
        //note that we must use the execute function in order to properly address the variable whose name we have stored in a strdef
        if( 0 == strcmp(format, "Bin") ) {
            sprint(tstr, "rec.AddVar( &%s(%lf), %d )", reportOn, x, sectionNo( $o1 ) )
            execute(tstr, this)
        } else if( 0 == strcmp(format, "Memory") ) {
            // in-memory report
            yvec = new Vector()
            cvode = new CVode()
            //cvode_active(0)
            cvode.active(1)
            sprint(tstr, "cvode.record(&%s(%1.2f), yvec, tvec)", reportOn, x)
            execute(tstr, this)
            memory_report.append(yvec)
        } else {
            sprint(tstr,"retVal = rec.addvar(%d, &%s(%1.2f))", rpt, reportOn, x )
            execute(tstr, this)
            if(retVal ==0){
                break
            }
            rec.addmapping( rpt, sectionNo( $o1 ) )
        }
    }    
}

//-----------------------------------------------------------------------------------------------

/*!
 * getter for the in-memory report list object
 *
 */
obfunc get_memory_report() {
    return memory_report 
}

//-----------------------------------------------------------------------------------------------
/*!
 * Generate a report for various current sources such that their current contributions are summed into a single value.  This single value
 * is on a per compartment basis, but may be further collapsed into a single value per cell.  Note that collapsing to a single value per cell is
 * not supported if multisplit is in use.
 *
 * @param $o1 Cell The cell getting reported
 * @param $o2 TPointList with the points for a single cell
 * @param $3 Flag indicating report is to collapse to single value for the cell (1) or run normal where each cmp gets a summed value
 * @param $4 vgid Optional argument for the split cell case; the virtual gid which may be different than the normal gid (bgid)
 */
proc addSummationReport() { local x, collapsed, vgid, rpt, intrinsicIndex, ptProcessIndex, result, scalar, dist, cmpID \
    localobj intrinsicList, ptProcessList, activeProcess, mechtype
    strdef tstr
    
    evaluateSummationReportOn( intrinsicList, ptProcessList )
    collapsed = $3
        
    //if no $4, use cell's gid
    if( numarg() == 4 ) {
        vgid = $4
    } else {
        vgid = $o1.gid
    }
    
    rpt = prepareReportForCell( $o1, $o2, vgid )
        
    //validate that we are not using multisplit and a collapsed summation report
    if( collapsed && $o1.gid != vgid ) {
        execerror( "Attempting to use a collapsed summation report while using mutlisplt\n" )
    }
    
    if( collapsed ) {  //Since the summations will be collapsed to a single value, we will store the ptprocess in the soma
        $o1.soma {
            ALUhelper = new ALU( 0.5, reportDt )
            ALUhelper.setop( "summation" )
        }
    }
    
    for $o2.each_point(&x) {
        mechtype = new MechanismType(1)
        
        if( !(collapsed) ) { //need 1 ALU per cmp
            ALUhelper = new ALU( x, reportDt )
            ALUhelper.setop( "summation" )
        }
        
        //intrinsic currents
        for intrinsicIndex=0, intrinsicList.count()-1 {
            //test if we can even access the desired current variable in this compartment 
            sprint(tstr,"{%s.%s(%1.2f)}", secname(), intrinsicList.o(intrinsicIndex).s, x )
            result = execute1(tstr, 0)
            if( result != 0 ) { //success, the var exists so we can add it
                if( area(x) != 0 ) {
                
                    //need to convert distributed current sources units.  NEURON stores/reports them as mA/cm^2; we want nA
                    // to convert, multiply by the area of the cmp (micron^2) then multiply by powers of 10 so units agree
                    scalar = area(x) / 100 // mA => nA :  * 10^6, cm^2 => micron^2 : 1/10^8
                    sprint(tstr,"{ALUhelper.addvar(&%s(%1.2f), %f)}", intrinsicList.o(intrinsicIndex).s, x, scalar)
                    execute(tstr, this)
                } else {
                    print "Warning (Error?) intrinsic property exists, but located where area = 0?"
                }
            }
        }
        
        //point processes - note that we *could* have collapsed reports add all point processes in a single section
        // at once, but that adds complexity to the code which may or may not save time        
        for ptProcessIndex=0, ptProcessList.count()-1 {
            mechtype.select( ptProcessList.o(ptProcessIndex).s )
            
            for( activeProcess=mechtype.pp_begin(); object_id(activeProcess) != 0; activeProcess = mechtype.pp_next() ) {
                
                dist = activeProcess.get_loc()
                cmpID = int(dist*nseg)
                if( cmpID == int(x*nseg) ) {
                    ALUhelper.addvar( &activeProcess.i )  //no scalar needed
                }
                pop_section()
            }
        }
        
        if( !(collapsed) ) {  //we commit one new ALU object per point
            addSummationVarAndCommitALU( sectionNo($o1), rpt )
        }
    }
    
    if( collapsed ) {  //otherwise, we commit one new ALU object per cell
        addSummationVarAndCommitALU( 0, rpt )
    }
}

//-----------------------------------------------------------------------------------------------

/*!
 * Helper function for adding a var for Summation reports where the only distinction is how the mapping
 * is computed.  The caller knows if the absolute index is needed (non-collapsed report) or just 0 for 
 * the soma (collapsed report)
 *
 * @param mapping index, i.e. the absolute index used to find this section in the morphology
 * @param rpt A handle to a report object, only used by HDF5/ASCII reports.  Ignored with Bin reports
 */
proc addSummationVarAndCommitALU() { local rpt
    //note that we must use the execute function in order to properly address the variable whose name we have stored in a strdef
    if( 0 == strcmp(format, "Bin") ) {
        sprint(tstr, "rec.AddVar( &ALUhelper.output, %d )", $1 )  //note that we force report on soma, so index=0
        execute(tstr, this)
    } else {
        rpt = $2
        sprint(tstr,"retVal = rec.addvar(%d, &ALUhelper.output)", rpt )
        execute(tstr, this)
        if(retVal ==0){
            break
        }
        rec.addmapping( rpt, $1 )
    }
    
    ALUList.append( ALUhelper )
}

//-----------------------------------------------------------------------------------------------

/*!
 * Helper function to determine which currents are to be reported in a summation report.
 *
 * @Param $o1 intrinsicList - List of intrinsic types (ions) generated in this function
 * @Param $o2 ptProcessList - List of point processes types (ions) generated in this function
 */
proc evaluateSummationReportOn() { localobj intrinsicList, ptProcessList, intrinsicLibrary, ptProcessLibrary
    intrinsicList = new List()
    ptProcessList = new List()

    //before scanning the ReportOn field, build some libraries that can be used for lookup and comparison    
    intrinsicLibrary = new List()
    intrinsicLibrary.append( new String( "ina" ) )
    intrinsicLibrary.append( new String( "ica" ) )
    intrinsicLibrary.append( new String( "ik" ) )
    intrinsicLibrary.append( new String( "i_pas" ) )
    intrinsicLibrary.append( new String( "i_cap" ) )
    intrinsicLibrary.append( new String( "ihcn_Ih" ) )     // \\
    intrinsicLibrary.append( new String( "ihcn_hcn3" ) )   //  ||- nonspecific currents are handled on an individual mod basis
    intrinsicLibrary.append( new String( "icsa_csa" ) )   // //

    ptProcessLibrary = new List()
    ptProcessLibrary.append( new String( "tmgExSyn" ) )
    ptProcessLibrary.append( new String( "tmgInhSyn" ) )
    ptProcessLibrary.append( new String( "SynAMPAEx" ) )
    ptProcessLibrary.append( new String( "SynNMDAEx" ) )
    ptProcessLibrary.append( new String( "ExpSyn" ) )
    ptProcessLibrary.append( new String( "ProbGABAA" ) )
    ptProcessLibrary.append( new String( "ProbAMPA" ) )
    ptProcessLibrary.append( new String( "ProbNMDA" ) )
    ptProcessLibrary.append( new String( "ProbAMPANMDA" ) )
    //Note - only synapse types are put in ptProcessLibrary, with IClamp getting checked separately.  Should we change that behavior?
    
    //split 'ReportOn' field on white space and check for special keywords - AllCurrent, SynapticCurrents, IntrinsicCurrents
    strdef token, sourceString, skipBlock
    sourceString = reportOn
    //print "src string ", sourceString
    while( strcmp( sourceString, "" ) != 0 )  {
        //find block of white space characters
        j = strobj.head( sourceString, "[ \t]+", token )
        if( j!=-1 ) {
            strobj.right( sourceString, j )
            //need to get first non-whitespace char
            j = strobj.head( sourceString, "[^ \t]+", skipBlock )
            if( j!=-1 ) {
                strobj.right( sourceString, j )
            } else {
                sourceString = ""
            }
        } else {
            token = sourceString
            sourceString = ""
        }
        //print "token ", token
        
        //check for special tokens for keywords
        if( strcmp(token, "AllCurrents") == 0 ) {
            //all current sources
            for libIndex=0, intrinsicLibrary.count()-1 {
                intrinsicList.append( intrinsicLibrary.o(libIndex) )
            }
            
            //synapses + point processes
            includeSyn = 1
            for libIndex=0, ptProcessLibrary.count()-1 {
                ptProcessList.append( ptProcessLibrary.o(libIndex) )
            }
            ptProcessList.append( new String( "IClamp" ) )
        } else if ( strcmp(token, "SynapticCurrents") == 0 ) {
            includeSyn = 1
            for libIndex=0, ptProcessLibrary.count()-1 {
                ptProcessList.append( ptProcessLibrary.o(libIndex) )
            }
        } else if ( strcmp(token,"IntrinsicCurrents") == 0 ) {
            for libIndex=0, intrinsicLibrary.count()-1 {
                intrinsicList.append( intrinsicLibrary.o(libIndex) )
            }
        } else {
            // Not matched yet, start scanning the lists for specific intance names
            matched = 0
            for libIndex=0, intrinsicLibrary.count()-1 {
                if( strcmp( token, intrinsicLibrary.o(libIndex).s ) == 0 ) {
                    intrinsicList.append( intrinsicLibrary.o(libIndex) )
                    matched = 1
                }
            }
            for libIndex=0, ptProcessLibrary.count()-1 {
                if( strcmp( token, ptProcessLibrary.o(libIndex).s ) == 0 ) {
                    ptProcessList.append( ptProcessLibrary.o(libIndex) )
                    matched = 1
                    includeSyn = 1
                }
            }
            if ( matched == 0 && strcmp(token,"IClamp") == 0 ) {
                includeSyn = 1
                matched = 1
                ptProcessList.append( new String( "IClamp" ) )
            }
            if ( matched == 0 && strcmp(token,"i_membrane") == 0 ) {
                matched = 1
                intrinsicList.append( new String( "i_membrane" ) )
            }
            if( matched == 0 ) {
                // Note that we now check for intrinsic names individually like with synapses.  Therefore, this else no longer
                //  needs to assume that an unmatched token is an ion.  (In the event new ions are added, we can update the lists)
                execerror( "Bad type given to Current Summation report: %s", token )
                
            }
        }
    }
    
    $o1 = intrinsicList
    $o2 = ptProcessList
}

endtemplate Report
