/*****************************************************************
    FileName    : TargetManager.hoc
    Project     : Blue Brain Project
    Place       : EPFL, Lausanne Switzerland.
    Purpose     : The TargetManager provides an entity to encapsulate the steps to get cell points for use in Stimulation or Reporting
                  This should make certain features of the simulation transparent such as load balancing and target file format
    Author      : 1. Jim King
    Revision    : $Revision:  $ at: $Date:  $ by $Author: $
****************************************************************/

//make sure we have some basic things loaded
{load_file( "nrngui.hoc" )}
{load_file( "Map.hoc" )}

//------------------------------------------------------------------------------------------
// 
//------------------------------------------------------------------------------------------

/**
 * When getting a location to a compartment by section index, the compartments must be serialized
 * and stored for future access.  Maybe we will better encapsulate this object?
 */
begintemplate SerializedSections

//-----------------------------------------------------------------------------------------------
// Declare member variables
//-----------------------------------------------------------------------------------------------

objref isec2sec[1] 

//-----------------------------------------------------------------------------------------------
// public members
//-----------------------------------------------------------------------------------------------

public isec2sec, init, count

//-----------------------------------------------------------------------------------------------
// Member function implementations
//-----------------------------------------------------------------------------------------------

/*!
 * Constructor serializes the sections of a cell for easier random access.
 *
 * $o1 Cell reference (basic cell, not a CCell)
 */
proc init() { local index
    
    n = $o1.nSecAll
    print "section count ", n
    
    objref isec2sec[n]
    
    index=1
    forsec $o1.all {
        if( v(0.0001) >= n ) {
            printf("%s v(1)=%d n3d()=%d\n", secname(), v(1), n3d())
			execerror("Error: failure in mk2_isec2sec()")
        }
        print index, v(0.0001)
        isec2sec[v(0.0001)] = new SectionRef()
        index = index+1
    }
}

/*!
 * @return The number of sections the cell originally had
 */
func count() {
    return n
}

endtemplate SerializedSections


//------------------------------------------------------------------------------------------
// Target Manager
//------------------------------------------------------------------------------------------

/**
 * Target Manager itself, providing the interface for the user to get cell points to use
 */
begintemplate TargetManager

{load_file("Target.hoc")}

//-----------------------------------------------------------------------------------------------
// Declare member variables
//-----------------------------------------------------------------------------------------------

objref targetList, loadBalanceInfo, pnm, cellList, sectionAccess, isec2sec[1]

//-----------------------------------------------------------------------------------------------
// public members
//-----------------------------------------------------------------------------------------------

public init, setLoadBalanceInfo
public getTarget, setTargetList, pnm, getPointList, locationToPoint

//-----------------------------------------------------------------------------------------------
// Member function implementations
//-----------------------------------------------------------------------------------------------

proc init() { local lastgid, cellIndex  localobj cellObj, secList, pointList
    
    if( argtype(1) == 1 ) {
        targetList = $o1
        
        if( argtype(2) == 1 ) {
            //should have recevied pnm
            pnm = $o2
        }
    }
    nErrors = 0
    
    sectionAccess = new Map()
}

//------------------------------------------------------------------------------------------

/*!
 * Assign a targetList (most likely created by a TargetParser) to this TargetManager
 *
 * @param $o1 Existing targetList this TargetManger should make a reference to.
 */
proc setTargetList() {
    targetList = $o1
}

//------------------------------------------------------------------------------------------

/*!
 * If this TargetManager is not being used for a bluebrain simulaion, the user must register
 * any cells so that the TargetManager can find them (under a bluebrain sim, the pnm object
 * or something wrapping it will be used)
 *
 * @param $o1 Reference to a cell object the user has created
 */
proc registerCell() {
    if( object_id(cellList) == 0 ) {
        cellList = new List()
    }
    
    //should I sort this list?  well, yes, but not now :P
    cellList.append( $o1 )
}

//------------------------------------------------------------------------------------------

/*!
 *  Helper function to aid debugging.  Print targets and info about them to stdout
 *  Required Inputs : 
 *  Logic           : For each target, print info about all targets to stdout
 */
proc printTargets() {
    //print names of targets found
    for targetIndex=0, targetList.count()-1 {
        print "Found target ", targetList.object(targetIndex).name
        print "\t All Cells: ", targetList.object(targetIndex).gidMembers.size()
        print "\t Local Cells: ", targetList.object(targetIndex).gids.size()
        print "\t Targets: ", targetList.object(targetIndex).subtargets.count()
        for subIndex=0, targetList.object(targetIndex).subtargets.count()-1 {
            print "\t\t", targetList.object(targetIndex).subtargets.o[subIndex].name
        }
    }
}

//------------------------------------------------------------------------------------------

/*!
 *  Public function which retrieve a target from the list and returns it to the caller
 *  Required Inputs : $s1 Name of target to find and retrieve
 *  Logic           : Use binary search to locate the target, throwing an error if the target
 *                    is not found
 */
obfunc getTarget() { local targetIndex  localobj targetUtil
    strdef errorMessage

    targetUtil = new TargetUtility()
    targetIndex = targetUtil.findTarget( $s1, targetList )
    if( targetIndex < 0 ) {  //not found, error
        print "Error: target ", $s1, " not found.  Attempting to terminate"
        sprint( errorMessage, "Error: target %s not found", $s1 )
        execerror( errorMessage )
    } else {
        return targetList.object(targetIndex)
    }    
}

//------------------------------------------------------------------------------------------

/*!
 * Retrieve TPointList for the requested item.  If a gid is passed, a TPointList is retrieved for the given gid; otherwise, 
 * a TargetName is expected and a List of TPointLists are retrieved for members of the Target which are local to the cpu
 *
 * @param $1 or $s1 gid of a cell registered with the TargetManager, or name of Target parsed from a target file
 * @return TPointList for single gid, List<TPointList> for Target
 */
obfunc getPointList() { localobj activeTarget
    
    //if cells were registered directly, use that cell list to get cell objects for addressing sections; otherwise,
    // we will use a pnm object (for now - maybe it will be wrapped in another object?)
    
    if( argtype(1) == 0 && object_id(cellList) ) {
        print "cellList implementation pending"
    } else if( argtype(1) == 2 && object_id(pnm) ) {
        
        activeTarget = getTarget($s1)
        return activeTarget.getPointList( pnm )
        
    } else {
        print "no cell list?  no pnm?  where am I supposed to get cell sections from?.  I'm leaving"
    }
}

//------------------------------------------------------------------------------------------

/*!
 * Given a location for a cell, section id, segment id, and offset into the segment, create a TPointList
 * containing a section reference to there
 *
 * @param $1 gid
 * @param $2 section index (isec)
 * @param $3 distance to start of segment (ipt)
 * @param $4 offset distance beyond the ipt (microns)
 * @return TPointList with 1 item, where the synapse should go
 */
obfunc locationToPoint() { local gid, distance, isec, ipt, offset, total  localobj resultPoint, cellSections, tmpSection, nil
    gid = $1
    isec = $2
    ipt = $3
    offset = $4

    resultPoint = new TPointList( gid )
    
    cellSections = gid2sections( gid )
    if( object_id(cellSections) == 0 ) {
        print "something is not implemented here..."
        quit()
    }
    
    distance = -1
    
    print "total sections (original) ", cellSections.count()
    tmpSection = cellSections.isec2sec[isec]
    
    if (tmpSection == nil) {  //assume we are in LoadBalance mode (until we decide to verify this either here or in a higher layer)
        resultPoint.append( tmpSection, -1 )
    }else {
        tmpSection.sec {
            // when a cell is split, the path from the split point
            // to the root gets its 3d points reversed because
            // the section orientation is reversed.
            if (section_orientation() == 1) {
                ipt = n3d() - 1 - ipt
                offset = -offset
            }
            if (ipt < n3d()) {
                distance = (arc3d(ipt)+offset)/L
                
                if( distance > 1.0 ) {
                    total = (arc3d(ipt)+offset)
                    //printf( "%%diff %g absdiff %g\n", (total-L)/L, (total-L) )
                    distance = 1.0
                }
            }
            if (section_orientation() == 1) {
                distance = 1 - distance
            }
        }
                
        resultPoint.append( tmpSection, distance )
    }
        
    return resultPoint
}

//------------------------------------------------------------------------------------------

/*!
 * For a given gid, we want SectionRefs stored in a List for random access.  This function will
 * see if such a List already exists and return it, or build that list as needed, storing it for the future before
 * returning the result.  Note that in split cases, the deleted sections will still have their SectionRefs.
 * Should this function instead go in the Node object?  The LoadBalance object?
 *
 * @param $1 gid
 * @return List object with SectionRefs to every section in the cell
 */
obfunc gid2sections() { local n  localobj searchString, resultSerial, nil, cellRef
    searchString = new String()
    sprint( searchString.s, "%d", $1 )
    
    resultSerial = sectionAccess.get( searchString )
    
    if( object_id(resultSerial) == 0 ) {  //must build new one
        //determine if we should use pnm or cellList based on which is actually allocated
        if( object_id(pnm) ) {
            cellRef = pnm.pc.gid2obj($1)
        } else if( object_id(cellList) ) {
            print "cellList implementation pending"
            return nil
        } else {
            print "no cell list?  no pnm?  where am I supposed to get cell sections from?.  I'm leaving"
            return nil
        }
        
        resultSerial = new SerializedSections( cellRef )
        
        sectionAccess.put( searchString, resultSerial )
    }
    
    return resultSerial
}

//------------------------------------------------------------------------------------------

/*!
 *  If the simulation is using LoadBalancing, a reference to the object handling that
 *  component can be provided which will be used to check when cells may be local/off node
 *  
 *  Required Inputs : $o1 Load balancing info
 *  Logic           : Save the reference for use during target accessing operations
 */
func setLoadBalanceInfo() {
    loadBalanceInfo = $o1
    
    //once loadbalance info is know, can localize targets.
    for targetIndex=0, targetList.count()-1 {
        targetList.object(targetIndex).localize( loadBalanceInfo.getGidListForProcessor(), loadBalanceInfo )
    }
}

endtemplate TargetManager
