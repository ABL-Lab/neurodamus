/*****************************************************************
    FileName    : TargetTemplate.hoc
    Project     : Blue Brain Project
    Place       : EPFL, Lausanne Switzerland.
    Purpose     : Encapsulate the operations surrounding a conceptual target used
                  by the Blue Brain Project to identify neurons or components of neurons
                  for stimulation, reporting, or other operations
    Author      : 1. Jim King
                  2. Rajnish Ranjan
    Revision    : $Revision$ at: $Date$ by $Author$
****************************************************************/

{load_file("stdlib.hoc")}
{load_file( "TPointList.hoc" )}

/*!
 * TargetUtility contains a collection of functions that are useful in the creation/maintenence/usage of targets
 * such as finding a target in a list of target objects sorted by name.  Also included is a basic binary search function 
 * that finds an int (gid) in a vector (gidvec)
 */
begintemplate TargetUtility

public findTarget, binary_search_contains

/*!
 *  Utility function for searching a List of targets objects and determining if any have
 *  the indicated name, returning either the index or a negative value which can be used to hint
 *  at where a target with such a name should be inserted into the list
 *  
 *  @param $s1 Name to search for
 *  @param $o2 Reference to List of sorted Targets to be searched
 *  @return The index of the target with the requested name, or negative value if not found.
 *  Logic           : Using a binary search, compare passed name with those of the targets in the list.
 *                    If target with same name found, return its index; otherwise, return special negative
 *                    value = -(potential_index+1) where potential_index is where a target with the passed
 *                    name would go if it were to be inserted.
 */
func findTarget() { local binsrch_low, binsrch_mid, binsrch_high localobj targetList
    targetList = $o2

    //search through list, using binary search to find if this target exists
    binsrch_low = 0
    binsrch_high = targetList.count()

    while ( binsrch_low < binsrch_high ) {
        binsrch_mid = int(( binsrch_low+binsrch_high)*0.5 )
        
        if( strcmp( targetList.object(binsrch_mid).name, $s1 ) < 0 ) { //guess again, lower
            binsrch_low = binsrch_mid+1
        } else {
            binsrch_high = binsrch_mid
        }
    }
    
    if( binsrch_low<targetList.count() ) {
        if( strcmp( targetList.object(binsrch_low).name, $s1 ) == 0 ) {
            //found it!
            return binsrch_low
        } else {
            //not found, but it can go here (return inverted index minus 1 )
            return -(binsrch_low+1)
        }
    }
        
    //not found, should be appended to list
    return -(targetList.count()+1)
}

//------------------------------------------------------------------------------------------------------------

/*!
 * Function to search a sorted vector for a value using binary search.  Can this be put somewhere
 * more common for general usage?
 *
 * @param $o1 sorted vector
 * @param $2 value to search for
 * @return 1 if the value is found, 0 if not found
 */
func binary_search_contains() { local binsrch_low, binsrch_high, binsrch_mid
    binsrch_low = 0
    binsrch_high = $o1.size()-1
    
    while ( binsrch_low <= binsrch_high ) {
        binsrch_mid = int(( binsrch_low+binsrch_high)*0.5 )

        if( $o1.x[binsrch_mid] > $2 ) { //guess again, lower
            binsrch_high = binsrch_mid-1
        } else if ( $o1.x[binsrch_mid] < $2 ) {  //guess again, higher
            binsrch_low = binsrch_mid+1
        } else {
            return 1
        }
    }

    return 0
}

/*!
 * - getPoints may be called by TargetManager without a Target object
 */
endtemplate TargetUtility

//------------------------------------------------------------------------------------------------------------
//------------------------------------------------------------------------------------------------------------
//------------------------------------------------------------------------------------------------------------

/*!
 * A Target is a collection of gids and potentially more information that designates points in the circuit
 * that may be accessed for things such as stimulus injection or report collection.
 */
begintemplate Target

//------------------------------------------------------------------------------------------------------------
// Declare Members Variables
//------------------------------------------------------------------------------------------------------------

//! Vector containing indexes into the original parsed list of gids, but only those gids on this local cpu
objref localCellsMap

//! 
objref gidMembers, subtargets, flattenedGids, completeFlattenedGids, binfo
objref cellExtraValues, targetExtraValues, cellSubsets, targetSubsets

strdef name, type

//------------------------------------------------------------------------------------------------------------
// Public Accessibility
//------------------------------------------------------------------------------------------------------------

public init

//! general information
public name, type
//! all gids listed directly within a target definition as parsed (i.e no gids from subtargets are included)
public gidMembers
//! list of references to other targets whose contents are to be included for certain operations
public subtargets

//! For section/cmp targets, there may be a subset descriptor (soma, axon, dend, apic, all) for each member (default=all)
public cellSubsets, targetSubsets
//! For section/cmp/synapse targets, lists of vectors for normalized distances or synapse ids
public cellExtraValues, targetExtraValues

//! memberfunctions - see below for detailed information
public evalType, isCellTarget, isSectionTarget, isCompartmentTarget, isSynapseTarget
public update, getgid, evaluateCompartments, gids, completegids, getCellExtraValues, evaluateSynapses, getPointList
public isDefined, completeContains, contains

//------------------------------------------------------------------------------------------------------------
// Member functions
//------------------------------------------------------------------------------------------------------------

proc init() {
    localCellsMap = new Vector()  //this is not public because it maps to indices of the gidMembers vector which might cause confusion
    gidMembers = new Vector()
    subtargets = new List()
    cellExtraValues = new List()
    targetExtraValues = new List()
    cellSubsets = new List()
    targetSubsets = new List()
	
	// 0=Cell, 1=Section, 2=Compartment, 3=Synapse
    typeCode = 0
    
    flattenedGids = new Vector()
    isFlattened = 0
    
    completeFlattenedGids = new Vector()
    isCompleteFlattened = 0
    
    //flag to indicate the target's contents are defined to prevent multiple targets with same name being *merged*
    isDefined = 0
}

//------------------------------------------------------------------------------------------------------------

/*!
 * @return 1 if this target is a Cell type; otherwise, returns 0
 */
func isCellTarget() {
    if( typeCode == 0 ) {
        return 1
    }
    return 0
}

//------------------------------------------------------------------------------------------------------------

/*!
 * @return 1 if this target is a Section type; otherwise, returns 0
 */
func isSectionTarget() {
    if( typeCode == 1 ) {
        return 1
    }
    return 0
}

//------------------------------------------------------------------------------------------------------------

/*!
 * @return 1 if this target is a Compartment type; otherwise, returns 0
 */
func isCompartmentTarget() {
    if( typeCode == 2 ) {
        return 1
    }
    return 0
}

//------------------------------------------------------------------------------------------------------------

/*!
 * @return 1 if this target is a Synapse type; otherwise, returns 0
 */
func isSynapseTarget() {
    if( typeCode == 3 ) {
        return 1
    }
    return 0
}

//------------------------------------------------------------------------------------------------------------

/*!
 *  After putting a string in the type field of this target, have it evaluate
 *  that string and set the appropriate internal target type code
 */
proc evalType() {
    if( strcmp( type, "Cell" ) == 0 ) {
        typeCode = 0
    } else if ( strcmp( type, "Section" ) == 0 ) {
        typeCode = 1
    } else if ( strcmp( type, "Compartment" ) == 0 ) {
        typeCode = 2
    } else if ( strcmp( type, "Synapse" ) == 0 ) {
        typeCode = 3
    } else {
        typeCode = -1 //invalid target type
    }
}

//------------------------------------------------------------------------------------------------------------

/*****************************************************************
    For each cell member in this target, determine if it exists on the local processor, and put it into localCellsMap (i.e. mapping that gid to an index).
    Required Inputs : $o1 Vector containing the gids of cells on this cpu
    Logic           : Since there should be fewer cells on node than in the target, actually checks each gid on node
                      for membership in this target.  If the cell is present, the index of the cell in the gidMembers vector
                      is kept (to maintain coordination with extra data)
*****************************************************************/
proc update() { local gid, cellIndex, binsrch_low, binsrch_high, binsrch_mid  localobj allCellIndices

    //Get a vector with indexes that tell the sorted order of the gidMembers vector (don't actually sort gidMembers or risk mixing up 'extra' data)
    allCellIndices = gidMembers.sortindex()
    localCellsMap = new Vector()
    //binfo = $o2
        
    //for each cell on node, determine if it exists in this target
    for cellIndex=0, $o1.size()-1 {

        //if (object_id($o2)) {
        //    gid = $o2.base_gid( $o1.x[cellIndex] )
        //} else {
            gid = $o1.x[cellIndex]
        //}
              
        //special binary_search - indirect vector access
        binsrch_low = 0
        binsrch_high = allCellIndices.size()
        
        while ( binsrch_low < binsrch_high ) {
            binsrch_mid = int(( binsrch_low+binsrch_high)*0.5 )

            if( gidMembers.x[allCellIndices.x[binsrch_mid]] < gid ) { //guess again, higher
                binsrch_low = binsrch_mid+1
            } else {
                binsrch_high = binsrch_mid
            }
        }
        
        if( binsrch_low<gidMembers.size() ) {
            if( gidMembers.x[allCellIndices.x[binsrch_low]] == gid ) { //present
                localCellsMap.append( allCellIndices.x[binsrch_low] ) //store the index into the global list
            }
        }
    }
}

/*****************************************************************
    The number of cells in this target that exist on this cpu (excluding cells in nested targets)
    Required Inputs : 
    Logic           : Return the size of the localCellsMap vector
*****************************************************************/
func localCount() {
	return localCellsMap.size()
}

//------------------------------------------------------------------------------------------------------------

/*!
 * Utility function for getting the gid of a cell.  Since the localCellsMap vector does NOT store gids, but actually
 * points to entries in the gidMembers vector, this function handles the indirection to hopefully avoid errors.
 *
 * @param $1 Index of desired cell
 * @return The gid of the cell
 */
func getgid() {
	//Note that localCellsMap is just a map into all the cells of this target
	return gidMembers.x[ localCellsMap.x[$1]]
}

//------------------------------------------------------------------------------------------------------------

/*!
 * Given an index of a local cell, return the corresponding 'extra' data.  i.e. normalized locations for compartment/section targets,
 * synapse ids for synapse targets.  Neuron targets have no extra data and will report an error is this function is called with one.
 * A similar function is not necessary for subtargets because they can be accessed intuitively with the targetIndex.  i.e. cellExtras
 * must be accessed indirectly using the index in localCellsMap which maps to a real index.
 * (i.e. the location in gidMembers where the gid is stored - see proc getgid() )
 *
 * @param $1 Index of cell
 * @return Vector with extra data (normalized locations or synapse ids)
 */
obfunc getCellExtraValues() {
	//localCellsMap is just a map into all the cells of this target
    if( isCellTarget() ) {
        print "Attempting to access extra positioning data (subset or normalized location info or synapse ids) for Cell target"
        execerror( "Attempting to access extra positioning data (subset or normalized location info or synapse ids) for Cell target" )
    }
	return cellExtraValues.object( localCellsMap.x[$1] )
}

//------------------------------------------------------------------------------------------------------------

/*!
 * Given an index of a local cell, return the corresponding subset name.  Neuron targets have no subsets and will report an error is this
 * function is called with one.
 * A similar function is not necessary for subtargets because they can be accessed intuitively with the targetIndex.  i.e. cellSubset
 * must be accessed indirectly using the index in localCellsMap which maps to a real index 
 * (i.e. the location in gidMembers where the gid is stored - see proc getgid() )
 *
 * @param $1 Index of cell
 * @return subset name
 */
obfunc getCellSubset() {
	//localCellsMap is just a map into all the cells of this target
    if( isCellTarget() ) {
        print "Attempting to access subset data for Cell target"
        execerror( "Attempting to access subset data for Cell target" )
    }
	return cellSubsets.object( localCellsMap.x[$1] )
}

//------------------------------------------------------------------------------------------------------------

/*****************************************************************
    Retrieve the flattened ids for this target, i.e. all cells ids in one vector including those from subtargets
    Required Inputs : 
    Logic           : if this target flattened itself previously, just return the existing vector; otherwise, instruct any
                      subtargets to flatten themselves and append their flattened vectors to mine.  The gids are then
                      sorted for faster searching
*****************************************************************/
obfunc gids() { local cellIndex targetIndex
    if( isFlattened == 1 ) {
        return flattenedGids
    }
    
    for cellIndex=0, localCellsMap.size()-1 {
        flattenedGids.append( getgid(cellIndex) )
    }
    
    for targetIndex=0, subtargets.count()-1 {
        flattenedGids.append( subtargets.object(targetIndex).gids() )
    }
	
	flattenedGids.sort()
    
    isFlattened = 1
    return flattenedGids
}


/*****************************************************************
    Certain cases require all gids from a target rather than just the once local to the cpu
    e.g. Prior to distribution, identifying gids as presynaptic cells, etc.  This function
    builds a vector with all cell gids (sorted) from a target and returns a reference to it
    Required Inputs : 
    Logic           : if this target flattened itself previously, just return the existing vector; otherwise, instruct any
                      subtargets to flatten themselves and append their flattened vectors to mine.  The gids are then
                      sorted for faster searching
*****************************************************************/
obfunc completegids() { local cellIndex targetIndex
    if( isCompleteFlattened == 1 ) {
        return completeFlattenedGids
    }
    
    completeFlattenedGids.append( gidMembers )
    for targetIndex=0, subtargets.count()-1 {
        completeFlattenedGids.append( subtargets.object(targetIndex).completegids() )
    }
	
	completeFlattenedGids.sort()
    
    isCompleteFlattened = 1
    return completeFlattenedGids
}

//------------------------------------------------------------------------------------------------------------

/*!
 * Determine if a given gid is included in the gid list for this target on the local cpu
 *
 * @param $1 gid to attempt to find
 * @return 1 if the gid is present, 0 if not included
 */
func contains() { localobj targetUtil
    targetUtil = new TargetUtility()
    return targetUtil.binary_search_contains( gids(), $1 )
}

//------------------------------------------------------------------------------------------------------------

/*!
 * Determine if a given gid is included in the gid list for this target regardless of which cpu
 *
 * @param $1 gid to attempt to find
 * @return 1 if the gid is present, 0 if not included
 */
func completeContains() { localobj targetUtil
    targetUtil = new TargetUtility()
    return targetUtil.binary_search_contains( completegids(), $1 )
}

//------------------------------------------------------------------------------------------------------------

/*!
 * Retrieve a TPointList containing compartments (based on target type and contents) of any local cells on the cpu.  I.e. If this target is
 *  a neuron target, its cells and cells from nested targets have soma(0.5) accessed.  If this target is a Section or Compartment target, 
 *  the cells and cells from nested targets will be accessed based on subset requests and normalized offset values (empty values for either are 
 *  interpreted as all subsets and/or all offset values)
 *  
 *  @param $o1 Reference to LoadBalance where cell objects and cell info can be retrieved
 *  @return TPointList where retrieved section references are stored
 */
obfunc getPointList() { local cellIndex, targetIndex  localobj gidVec, pointVector, activeTarget, pointListList, activePointList
	strdef token, NeuronName, SecName
    
    pointListList = new List()
	
	if( isCellTarget() ) {  //get all cells, and address soma(0.5)
		gidVec = gids()
		
		pointVector = new Vector()
		pointVector.append( 0.5 )
        for cellIndex=0, gidVec.size()-1 {
            activePointList = new TPointList()
			addressSectionPoints( $o1, gidVec.x[cellIndex], "soma", 0, pointVector, activePointList )
            pointListList.append( activePointList )
		}
        
        return pointListList
        
	} else if( isSectionTarget() ) {
        pointVector = new Vector()
        pointVector.append(0.5)
        
        //for each cell member
        for cellIndex=0, localCellsMap.size()-1 {
            addressSectionPoints( $o1, getgid(cellIndex), getCellExtraValues(cellIndex), pointVector, $o2 )
        }
        
        //for each subtarget
        for targetIndex=0, subtargets.count()-1 {
            activeTarget = subtargets.object( targetIndex )
            if( activeTarget.isCellTarget() ) {  //only do stuff if it is a cell target?  no nesting section targets in each other?
                
                gidVec = activeTarget.getFlatVec()  //get all gids from that target and its subtargets
                for cellIndex=0, gidVec.size()-1 {
                    addressSectionPoints( $o1, gidVec.x[cellIndex], targetExtraValues.object( targetIndex ), pointVector, $o2 )
                }
            } else { //if( $o1.myid == 0 ) {
                print "Warning: detected non-cell subtarget nested in Section target.  Skipping"
            }
        }
        
	} else if( isCompartmentTarget() ) {
    
        //for each cell member
        for cellIndex=0, localCellsMap.size()-1 {
			activePointList = new TPointList()
            addressCompartmentPoints( $o1, getgid(cellIndex), getCellSubset(cellIndex).s, getCellExtraValues(cellIndex), activePointList )
			pointListList.append( activePointList )
        }
        
        //for each subtarget
        for targetIndex=0, subtargets.count()-1 {
            activeTarget = subtargets.object( targetIndex )
            if( activeTarget.isCellTarget() ) {  //only do stuff if cell or section target?  no nesting cmp targets in each other?
                
                gidVec = activeTarget.gids()  //get all gids from that target and its subtargets
                for cellIndex=0, gidVec.size()-1 {
					activePointList = new TPointList()
                    addressCompartmentPoints( $o1, gidVec.x[cellIndex], targetSubsets.o(cellIndex).s, targetExtraValues.object(targetIndex), activePointList )
					pointListList.append( activePointList )
                }
                
            } else if( activeTarget.isSectionTarget() ) {
                addressCompartmentPointsInSection( $o1, activeTarget, targetExtraValues.object(targetIndex), $o2 )
            } else { //if( $o1.myid == 0 ) {
                print "Warning: detected non-cell, non-section subtarget nested in Compartment target.  Skipping"
            }
        }
		
		return pointListList
    
    } else if (isSynapseTarget() ) {
        print "Synapse Targets not supported"
    } else {
        print "Invalid Target type for target ", name
    }
}

/***************************************************************************************
    Retrive the synapse ids for a given id from this target
    Required Inputs : $1 gid whose synapses are needed
                      $o2 Vector where synapse ids are to be stored
    Logic           : 
****************************************************************************************/
proc evaluateSynapses() { local val, synIndex, binsrch_low, binsrch_high, binsrch_mid localobj synstrings

    //find the gid in my cell list by using binary search on localCellsMap
    binsrch_low = 0
    binsrch_high = localCellsMap.size()
    
    while ( binsrch_low < binsrch_high ) {
        binsrch_mid = int(( binsrch_low+binsrch_high)*0.5 )

        if( gidMembers.x[ localCellsMap.x[binsrch_mid] ] < $1 ) { //guess again, higher
                binsrch_low = binsrch_mid+1
        } else {
            binsrch_high = binsrch_mid
        }
    }
        
    if( binsrch_low < localCellsMap.size() ) {
        if( gidMembers.x[ localCellsMap.x[binsrch_low] ] == $1 ) { //present - extract the synapse ids
            $o2.append( cellExtraValues.o[localCellsMap.x[binsrch_low] ] )
            return
        }
    } 
    
    //if reaches here, cell was not in cell list; subtargets not supported (yet)
    print "Warning: gid ", $1, "not found in direct gid member list (Synapse targets do not support nesting yet)\n"
}



/*****************************************************************
    For Section targets nested in Compartment targets, apply both compartment location address and section
    location address to neurons to hone in on particular points
    
    Required Inputs : $o1  Parallel Net manager
                      $o2  Section Target
                      $s3  Compartment nos in string (no subsets allowed?)
                      $o4 (return value) reference of list object which will contain the CellInfo List
    Logic           : 
*****************************************************************/
proc addressCompartmentPointsInSection(){local  ret, cnt, val, cellIndex, targetIndex  localobj strList, tVec, tgidVec, activeTarget
/*
    strList =   new List()
    tVec    =   new Vector()
    ret     =   split($s3, strList)          
    for cnt =0, strList.count-1 {
        sscanf(strList.o(cnt).s, "%f", &val)
        tVec.append(val)
    }
    
    //get the cells from the passed target
    for cellIndex=0, $o2.localCount()-1 {
        addressSectionPoints( $o1, $o2.getgid(cellIndex), $o2.getCellExtra(cellIndex).s, tVec, $o4 )
    }
    
    //for all subtargets of the given section target
    for targetIndex=0, $o2.subtargets.count()-1 {
        
        //work with flattened gids of this subtarget
        activeTarget = $o2.subtargets.object( targetIndex )
        tgidVec = activeTarget.getFlatVec()
        for cellIndex=0, tgidVec.size()-1 {
            addressSectionPoints( $o1, tgidVec.x[cellIndex], $o2.targetExtra.object(targetIndex).s, tVec, $o4 )
        }
    }    
    */
}


/*****************************************************************
    Use the extra data of a compartment target to identify locations of a neuron to address, limiting to a certain
    section subset if specified.  Any locations given on the line are compartment locations as opposed to section locations
    
    Required Inputs : $o1 Parallel Net Manager
                      $2 Neuron gid
					  $s3 String with subset name (or "" for all subsets)
                      $o4 Vector with normalized locations
                      $o5 (return value) reference to TPointList object which will store resulting points
    Logic           : 
*****************************************************************/
proc addressCompartmentPoints(){ local ret, cnt, val  localobj strList, tVec
	
	tVec = new Vector() //pass empty vector to represent all sections
	
	addressSectionPoints( $o1, $2, $s3, tVec, $o4, $o5 )
}


/*!
 *  Use the extra data of a section target to identify locations on a neuron that must be addressed
 *  and apply and compartment addressing to the neuron as well
 *  
 *  @param $o1 Parallel net manager reference
 *  @param $2 Neuron gid                     
 *  @param $s3 subset
 *  @param $o4 Vec of section points
 *  @param $o5 Vec of compartments points
 *  @param $o6 (return value) reference to TPointList object which will be populated with section references
 */
proc addressSectionPoints(){ local gid, count, retVal, SecSize, SecNo localobj strList, tobj, tCInfo
    strdef  SecName, NeuronName
    strList =   new List() 
    
    gid = $2
    tobj    =   $o1.getCell( gid )
    sprint(NeuronName, "%s", tobj)

    if( 0 == strcmp( $s3, "" ) ) {  //want all sections - soma, axon, apic, dend
        addressSoma( $o1, gid, $o5, $o6 )
        
        SecSize = tobj.nSecAxonal
        for count=0, SecSize-1 {
            addressSection( $o1, gid, "axon", count, $o5, $o6 )
        }
        
        SecSize = tobj.nSecBasal
        for count=0, SecSize-1 {
            addressSection( $o1, gid, "dend", count, $o5, $o6 )
        }
        
        SecSize = tobj.nSecApical
        for count=0, SecSize-1 {
            addressSection( $o1, gid, "apic", count, $o5, $o6 )
        }
    } else { //wanted one section type exclusively
        if( 0 == strcmp( $s3, "soma" ) ) {
            addressSoma( $o1, gid, $o5, $o6 )
            return
        } else if ( 0 == strcmp( $s3, "axon" ) ) {
            SecSize = tobj.nSecAxonal
        } else if ( 0 == strcmp( $s3, "dend" ) ) {
            SecSize = tobj.nSecAxonal
        } else if ( 0 == strcmp( $s3, "apic" ) ) {
            SecSize = tobj.nSecAxonal
        }
        
        if ( $o4.size() == 0 ) {  //address all points of requested section
            for count=0, SecSize-1 {  
                addressSection( $o1, gid, $s3, count, $o4, tCInfo)
            }
        } else {  //address only those section points told
            for count=0, $o4.size()-1 {
                SecNo   =    getSectionNo(SecSize, $o4.x[count])
                addressSection( $o1, id, $s3, SecNo, $o5, $o6 )
            }
        }
    }
}

/*****************************************************************
    Addresses into a section at the given locations, or all locations if none are told
    Required Inputs : $o1  Parallel Net Manager
                      $2   base gid
                      $s3  SecName
                      $4   SecNo        
                      $o5  Vector each element containing Compartment ref.
                      $o6  TPointList
    Logic           : 
*****************************************************************/
proc addressSection(){local segcnt, SegNo, locIndex  localobj VecObj, tObj
	strdef tstr, tstr1
    //get the actual cell object prom pnm
    
    tObj = $o1.getCell( $2 )
    //tObj = $o1.pc.gid2obj($2)
    
    if(!section_exists($s3,$4 ,tObj)) {
		return
    }
    
    sprint(tstr, "%s.%s[%d]", tObj, $s3, $4)
    VecObj  = $o5
    if(VecObj.size == 0){  //the vector was empty, so need to address all points
        VecObj  = new Vector()
        sprint(tstr1, "access %s", tstr)
        execute(tstr1)
        for segcnt =1, nseg {
            VecObj.append(segcnt/(nseg+1))
        }       
    }
    
	for locIndex=0, VecObj.size()-1 {
		$o6.append( tstr, VecObj.x[locIndex] )
	}
}

/*****************************************************************
    This function addresses into the soma of the given cell at the given location(s), or 
    for all sections (i.e. 1 @ 0.5) if no locations were given
    Required Inputs : $o1  Parallel Net manager reference
                      $2   base gid
                      $o3  Vector with each element containing a Compartment location (typically 0.5).
                      $o4  TPointList for this gid  where section refs will be stored
    Logic           : Get the cell, determine which locations need addressing, put into CellInfo Obj
*****************************************************************/
proc addressSoma(){local segcnt, SegNo localobj VecObj, cellObj
    //get the actual cell object from the pnm
	strdef tstr, tstr1
    //cellObj = $o1.pc.gid2obj($2)
    
    cellObj = $o1.getCell( $2 )
    
    //make sure it has a soma - if we are returning a complete TPointList, what do I append?  Also, how do I remember I am in 
    // 'complete' mode?  Should I just pass a flag around these functions?
    if(!section_exists("soma", cellObj)) {
        
        //TODO: insert null reference into TPointList of requested to return 'complete'
        return
    }
    
    sprint(tstr, "%s.soma", cellObj )
    VecObj  = $o3
    
    //If no normalized section references were specified, then supply all of them (of course the soma typically only has one)
    if(VecObj.size == 0){
        VecObj  = new Vector()
        sprint(tstr1, "access %s", tstr)
        execute(tstr1)
        for segcnt=1, nseg {
            VecObj.append(segcnt/(nseg+1))
        }
    }
    
    //add the address string and the vector of normalized section references
    for segcnt=0, VecObj.size-1 {
        $o4.append( tstr, VecObj.x[segcnt] )
    }
}

//------------------------------------------------------------------------------------------------------------

/*!
 *  Map an actual index for a section from a normalized value
 *
 *  @param $1 Total section count
 *  @param $2 Normalized section value
 *  @return The resulting section index
 */
func getSectionNo(){ local SecNo
    
    if( $2>=0 && $2 <=1){        
        SecNo = $2 * ($1-1)
    }else {
        print "Error Normalized Section not wothin range 0 to 1"
        execerror("Error Normalized Section not wothin range 0 to 1")
    }
    
    return(int(SecNo))
}

endtemplate Target
