/*****************************************************************
    FileName    : StimulusManager.hoc
    Project     : Blue Brain Project
    Place       : EPFL, Lausanne Switzerland.
    Purpose     : Process Synapse connections Rules of a BlueConfig (if any) and then instantiate the synapses 
                  for a bluebrain sim
    Author      : 1. Jim King
                  2. Rajnish Ranjan
    Revision    : $Revision$ at: $Date$ by $Author$
****************************************************************/

{load_file("alib/TStim.hoc")}  //note that the TStim functions are used in a way where our naming schemes don't match 100%
{load_file("alib/EStim.hoc")}

begintemplate StimulusManager

//-----------------------------------------------------------------------------------------------
// Declare member variables
//-----------------------------------------------------------------------------------------------

objref stimList, elecManager, targetManager, this

//! For use in poisson stims, when creating via the execute stmt, need to have class level object (not just local to function)
objref stimHelper, poissonNetconList, handleList, poissonSynList

//-----------------------------------------------------------------------------------------------
// public members
//-----------------------------------------------------------------------------------------------

public init, linear, interpret, FillSpikeTrain, interpretExtracellulars

//-----------------------------------------------------------------------------------------------
// Member function implementations
//-----------------------------------------------------------------------------------------------

/*!
 * Typical constructor, create empty list where stimulus are stored as they get generated, keep reference
 * to TargetManager for accessing Targets
 *
 * @param $o1 TargetManager
 * @param $o2 Electrode Manager for extracellular stimulation (optional)
 */
proc init() {
    stimList = new List()
    targetManager = $o1
    if( numarg() == 2 ) {
        elecManager = $o2
    }
    //keep track of how many poisson stims we create so that the seeds can be offset (otherwise we would have same syns/spike trains in a given cell)
    poissonStimCount = 0
    poissonNetconList = new List()
    poissonSynList = new List()
    handleList = new List()
}

//-----------------------------------------------------------------------------------------------

//----------------------------------------------------------------------------------------------
/*!
 * Helper function to get an overview over the requested extracellular stimuli. interpretExtracellulars() needs 
 * them in the following format: A map(String,List), where the key is the target name and the object is 
 * a List of Maps containing Stimulus parameters. Because it is a rather complicated structure to set up, I do
 * it in a separate function.
 * 
 * @param $o1 injRequests - the list of maps containing info on requested StimulusInjects
 * @param $o2 parsedStimuli - Maps containing the information on defined stimuli
 * 
 */

obfunc getExtracellularParams() { local injIndex localobj listForTarget, newListObj, injRequests, stimName, targetName, stim, paramValue, extraList, nil
	if($o1 == nil){
		print "injRequests are NULL!"
	}
	if($o2 == nil){
		print "parsedStimuli are NULL!"
	}
	injRequests = $o1
	extraList = new Map()
	for injIndex=0, injRequests.count()-1 {
	    	stimName = injRequests.o(injIndex).get( "Stimulus" )
			targetName = injRequests.o(injIndex).get( "Target" )
			stim = $o2.get( stimName )
			paramValue = stim.get( "Mode" )
			if( strcmp( paramValue.s, "Extracellular" ) == 0 ) {
				listForTarget = extraList.get(targetName)
				if( listForTarget == nil ){
					newListObj = new List()
					newListObj.append(stim)
					extraList.put( targetName, newListObj )
				} else {
					listForTarget.append(stim)
				}				
			}
	}
	return extraList
}


//-----------------------------------------------------------------------------------------------
/*!
 * This function handles all the requested extracellular stimuli. It uses helper function getExtracellularParams 
 * to get an overview over requested extracellular stimuli
 * 
 *
 * @param $o1 injRequests - the list of maps containing info on requested StimulusInjects
 * @param $o2 parsedStimuli - Maps containing the information on defined stimuli
 * 
 */
proc interpretExtracellulars() { local cellIndex, targetIndex, stimIndex, elecIndex, scaleFac, secType, secNum, offset, tx, ty, tz, x localobj stimlist, eName, pts, gidObj, stim, estim, paramValue, activeElectrode, nil
    
    //verify that electrode manager was passed to StimulusManager
    if( elecManager == nil ) {
        execerror("Error: attempting to use extracellular stimulation without ElectrodeManager" )
    }
	
	stimlist = getExtracellularParams($o1,$o2)	
	for targetIndex=0, stimlist.count()-1{ //over all unique targets
		//print "Treating extracellulars for target: ", stimlist.key(targetIndex).s
		pts = targetManager.getPointList(stimlist.key(targetIndex).s) //get that target
		gidObj = targetManager.gids(stimlist.key(targetIndex).s)
		
		for elecIndex = 0, elecManager.count()-1{ //over all electrodes
			//Now we have every combination of electrode and target. We collect all Stimuli using a given combination,
			//Fill them into one EStim object and do the frequency dependent conversion. Then we Vector.play() it into
			//Every compartment of the target			
			eName = elecManager.getName(elecIndex)			
			activeElectrode = elecManager.getElectrode(elecIndex)			
			estim = new EStim() //Create one EStim per electrode!
			for stimIndex=0, stimlist.o(targetIndex).count()-1 { //Now gather every stimulus using this electrode
				stim = stimlist.o(targetIndex).o(stimIndex)
				// No longer checking for type of stimulus at this stage!
				paramValue = stim.get( "Electrode" )
				//Compare Electrode name. TODO: Need to find a solution for lookup by location.
				//Also: Maybe do this with a Map object?
				if( paramValue != nil && (strcmp(paramValue.s,eName.s)==0) ){
					estim.train( stim.valueOf( "Delay" ), stim.valueOf( "Duration" ), stim.valueOf( "AmpStart" ), stim.valueOf( "Frequency" ), stim.valueOf( "Width" ) )					
				}								
			}
			estim.initElec() //now that we treated all stimuli using this electrode we can initiate it
			for cellIndex=0, pts.count()-1 { //Now over all compartments in the target
				scaleFac = 0
				for pts.o(cellIndex).each_point(&x) {
					if(!ismembrane("extracellular")){
						insert extracellular
					}
					if(!getSecTypeAndIndex(&secType,&secNum)){	//Now get the scale factor based on distance
						if(activeElectrode.vInfo()>4){ //version 4 has one value per compartment, <4 only one per Section							
							scaleFac = activeElectrode.getValueForSection(gidObj.x[cellIndex],secType,secNum,x)
						} else {
							scaleFac = activeElectrode.getValueForSection(gidObj.x[cellIndex],secType,secNum)
						}
						if(scaleFac == 0){	//No need to inject anything. 0 is default value for e_extracellular					
							continue
						}
					} else {
						print "Problem identifying section type and number for", secname()
						quit()
					}					
					estim.inject(x,scaleFac)
				}				
			}
			stimList.append(estim)
		}
	}
}

/*!
 * For handling stimulus which has been parsed from a file - look at the parameters collected and
 * call the appropriate stimulus functions
 *
 * @param $s1 targetName - which target where stimulus should be injected
 * @param $o2 stim - map containing stimulus parameters
 * 
 * alternatively for Ruben's PFE
 * @param $o1 TPointList where stimulus will be injected
 * @param $o2 stim - map containing stimulus parameters
 * @param $3 gid of cell
 */
proc interpret() { local tempVal, del, dur, relamp, threshold  localobj stim, target, paramValue, paramVect, patternName, nil

    stim = $o2
    
    paramVect = new Vector()
	paramValue = stim.get( "Mode" )
	if( strcmp( paramValue.s, "Extracellular" ) == 0 ) { 
		//Extracellular stimuli handled separately
		return
	}else if( strcmp( paramValue.s, "Current" ) != 0 ) {
		print "Invalid Mode - ", paramValue.s
		return
	}    
    
    //all will have Delay and Duration, so parse immediately
    del = stim.valueOf( "Delay" )
    dur = stim.valueOf( "Duration" )
    
    //more specific parameters based on pattern
    patternName = stim.get( "Pattern" )
    
    // Ruben's pfe chunk
    //
    // check for TPointList argument
    if( argtype(1) == 1 ) {
        // SquarePulse for TPointList arg
        if( strcmp( patternName.s, "SquarePulse" ) == 0 ) {
            relamp = stim.valueOf( "relAmp" )
            //threshold = targetManager.getCell($3).getCCell().getThreshold()
            threshold = targetManager.getCell($3).getThreshold()
            squarepulse( $o1, relamp * threshold, del, dur )
        }
    //
    // check for target name argument
    } else if( argtype(1) == 2 ) {
        // SquarePulse for target name arg
        if( strcmp( patternName.s, "SquarePulse" ) == 0 ) {
            relamp = stim.valueOf( "relAmp" )
            threshold = targetManager.getCells($s1).o(0).getCCell().getThreshold()
            linear( $s1, relamp * threshold, relamp * threshold, del, dur )
        } else if( strcmp( patternName.s, "Linear" ) == 0 ) {
            paramVect.append( stim.valueOf("AmpStart") )
            
            //optional option - AmpEnd.  If not there, use same value as AmpStart
            if( stim.get( "AmpEnd" ) != nil ) {
                paramVect.append( stim.valueOf("AmpEnd") )
            } else {
                paramVect.append( paramVect.x[paramVect.count()-1] )
            }
            
            linear( $s1, paramVect.x[0], paramVect.x[1], del, dur )
        } else if ( strcmp( patternName.s, "Pulse" ) == 0 ) {
            //looking at bglib, it expects potentially multiple delay/duration pairs (and an AmpEnd)
            // TODO: rename bglib's stimulus pattern names to be inline with TStim, creating 'train' as replacement for bglib's 'pulse'
            
            paramVect.append( stim.valueOf( "AmpStart" ) )
            paramVect.append( stim.valueOf( "Frequency" ) )
            paramVect.append( stim.valueOf( "Width" ) )
            
            //optional argument - Offset; default = 0.
            // TODO: re-evaluate offset for Pulse stimulus and debug because it looks like it might not be multisplit safe
            if( stim.get( "Offset" ) != nil ) {
                paramVect.append( stim.valueOf( "Offset" ) )
            } else {
                paramVect.append( 0 )
            }
            
            train( $s1, paramVect.x[0], paramVect.x[1], paramVect.x[2], paramVect.x[3], del, dur )
            //linear( $s1, paramVect.x[0], paramVect.x[0], del, dur )
        } else if(strcmp(patternName.s, "Sinusoidal")==0){        	
        	paramVect.append( stim.valueOf("AmpStart"))
			paramVect.append( stim.valueOf("Frequency"))
			if( stim.get( "Offset" ) != nil ) {
				paramVect.append( stim.valueOf( "Offset" ) )
			} else {
				paramVect.append( 0 )
			}
        	sinusoid($s1, paramVect.x[0], paramVect.x[1], paramVect.x[2], del, dur)
        } else if( strcmp( patternName.s, "NPoisson" ) == 0 ) {
            paramVect.append( stim.valueOf( "Lambda" ) )
            paramVect.append( stim.valueOf( "Weight" ) )
            paramVect.append( stim.valueOf( "NumOfSynapses" ) )
            
            //Note: SynapseType is optional and will return nil (handled by npoisson function)
            //Note: requires special Target handling, so just pass targetName through
            npoisson( $s1, paramVect.x[0], paramVect.x[1], paramVect.x[2], stim.get( "SynapseType" ), del, dur )
        } else if( strcmp( patternName.s, "SubThreshold" ) == 0 ) {
            subthreshold( $s1, stim.valueOf( "PercentLess" ), del, dur )
        }
    }
}

//-----------------------------------------------------------------------------------------------

/*!
 * Injects a squarepulse stimulus into a cell. Takes a TPointList, not a target, as first argument
 *
 * @param $o1 TPointList of points where iclamps will be placed
 * @param $2 amp amplitude of the current injected (nA)
 * @param $3 delay from start of simulation to when current is injected (ms)
 * @param $4 duration of stimulus (ms)
 */
proc squarepulse() { local cellIndex, x, amp, del, dur  localobj pts, tstim
    
    amp = $2
    del = $3
    dur = $4

    //since there are no random elements, we can just evaluate the pointlist and proceed as normal
    pts = $o1
    
    for pts.each_point(&x) {
        
        tstim = new TStim(x)
        
        tstim.pulse( del, dur, amp)
        stimList.append( tstim )
    }
}

//-----------------------------------------------------------------------------------------------

/**
 * Injects a pulse stimulus into the targeted locations scaled to some percentage of that cell's threshold
 * current (the current needed to cause 1 AP)
 *
 * @param $s1 Target name which should receive the stimulus
 * @param $2 Percent less than full threshold current (e.g. val of 5 indicates that 95% of threshold is to be injected
 * @param $3 del
 * @param $4 dur
 */
proc subthreshold() { local cellIndex, x  localobj pts, cellList, tstim

    pts = targetManager.getPointList($s1)
    cellList = targetManager.getCells($s1)
    
    for cellIndex=0, pts.count()-1 {
        for pts.o(cellIndex).each_point(&x) {
            tstim = new TStim(x)
            
            tstim.pulse( $3, $4, cellList.o(cellIndex).getCCell().getThreshold()*(100-$2)/100 )
            stimList.append(tstim)
        }
    }
}

//-----------------------------------------------------------------------------------------------

/*!
 * Injects a train stimulus into cells wih regular frequency.
 *
 * @param $s1 Name of Target where stims will be placed
 * @param $2 amp
 * @param $3 frequency
 * @param $4 width
 * @param $5 offset std dev
 * @param $6 del
 * @param $7 dur
 */
proc train() { local cellIndex, x, offset, secIndex, foo  localobj pts, tstim, jitter

    pts = targetManager.getPointList($s1)
        
    for cellIndex=0, pts.count()-1 {
    	offset = 0
        if( $5 != 0 ) {
            jitter = new Random( pts.o(cellIndex).gid )
            jitter.normal(0,$5)
        }               
        for pts.o(cellIndex).each_point(&x) {
            tstim = new TStim(x)            
            if( $5 != 0 ) {
            	if($5<0){            		            	
            		offset = offset-$5            			
            	} else {
                offset = jitter.repick()
            	}
            }
            tstim.train( $6+offset, $7, $2, $3, $4 )
            
            stimList.append(tstim)
        }
    }
}

/*!
 * Injects a sinusoidal stimulus into cells wih regular frequency.
 *
 * @param $s1 Name of Target where stims will be placed
 * @param $2 amp
 * @param $3 frequency
 * @param $4 offset std dev
 * @param $5 del
 * @param $6 dur
 */
proc sinusoid() { local cellIndex, x, offset, secIndex, foo  localobj pts, tstim, jitter	
    pts = targetManager.getPointList($s1)    
    offset = 0
    for cellIndex=0, pts.count()-1 {
    	offset = 0
        if( $4 != 0 ) {
            jitter = new Random( pts.o(cellIndex).gid )
            jitter.normal(0,$4)
        }        
        for pts.o(cellIndex).each_point(&x) {
            tstim = new TStim(x)            
            if( $4 != 0 ) {
            	if($4<0){
            		offset = offset-$4            		
            	} else {
                offset = jitter.repick()
            	}
            }            
            tstim.sin($2,$5+offset,$6,$3)            
            stimList.append(tstim)
        }
    }
}

//-----------------------------------------------------------------------------------------------

/*!
 * Injects a square pulse into a cell.  Note that if the starting and ending amplitude are the same,
 * a simple 
 *
 * @param $s1 Name of Target where iclamps will be placed
 * @param $2 ampStart Starting amplitude of the current injected (nA)
 * @param $3 ampEnd Final amplitude of the current when done injecting (nA)
 * @param $4 delay from start of simulation to when current is injected (ms)
 * @param $5 duration of stimulus (ms)
 */
proc linear() { local cellIndex, x, ampStart, ampEnd, del, dur  localobj pts, tstim
    
    ampStart = $2
    ampEnd = $3
    del = $4
    dur = $5

    //since there are no random elements, we can just evaluate the pointlist and proceed as normal
    pts = targetManager.getPointList($s1)
    
    for cellIndex=0, pts.count()-1 {
        for pts.o(cellIndex).each_point(&x) {
            
            tstim = new TStim(x)
            
            if( ampStart == ampEnd ) {
                tstim.pulse( del, dur, ampStart )
            } else {
                tstim.ramp( 0, del, ampStart, ampEnd, dur, 0, 0 )
            }
            
            stimList.append( tstim )
        }
    }
}

//-----------------------------------------------------------------------------------------------

/*!
 * Apply a poisson stimulus over n artificial synapses distributed randomly on a cell's basal and apical sections
 * 
 * @param $s1 TargetName
 * @param $2 lambda
 * @param $3 weight
 * @param $4 number of synapses
 * @param $o5 synapseType as String or nil if should use default (ExpSyn)
 * @param $6 delay from start of simulation to when stimulus starts (ms)
 * @param $7 duration of stimulus (ms)
 */
proc npoisson() { local cellIndex  localobj apicalPoints, basalPoints, gids
    
    //The synapses generated should only go on the apical or basal sections of any target cells
    // difficulty for doing exactly same thing as old bglib: that could operate easily on the section
    // of a cell, but now we work with compartment points only(?)  If so, random selection won't be the same
    // maybe the utility function of targetManager can return only the middle of all sections?
    // e.g Target section helper
    //     {
    //         base_target apic  //note that base_target must be a cell target, if section target, that is fine
    //         base_target dend
    //     }
    
    // open for interpretation - should I get the target, check they type and take action based on that?
    //  or should I send two requests to the targetManager asking for the apic & basal sections, letting
    //  the manager do checks and balances
    gids = targetManager.gids( $s1 )
    apicalPoints = targetManager.getApicalSections( $s1 )
    basalPoints = targetManager.getBasalSections( $s1 )
    
    //for each gid/TPointList - place synapses randomly and supply a spike train
    for cellIndex=0, gids.size()-1 {
        
        //so all cells should be represented and have the same point count regardless of splitting        
        distributePoissonSynapses( gids.x[cellIndex], $2, $3, $4, $o5, $6, $7, apicalPoints.o(cellIndex), basalPoints.o(cellIndex) )
    }
    
    poissonStimCount = poissonStimCount + 1
}

//-----------------------------------------------------------------------------------------------

func getSecTypeAndIndex() { local baseOffset, secIndex  localobj str, strobj
	strdef subset
	str = new String()
strobj = new StringFunctions()
if( strobj.substr( secname(), "soma" ) > 0 ) {
	subset = "soma"
			$&1 = 1
} else if (strobj.substr( secname(), "axon") >0) {
	subset = "axon"
			$&1 = 2
}else if (strobj.substr( secname(), "dend") >0) {
	subset = "dend"
			$&1=3
}else if (strobj.substr( secname(), "apic") > 0) {
	subset = "apic"
			$&1=4
} else {
	return 1
}
// parse out the index from the secname
strobj.tail( secname(), subset, str.s )
		if (strobj.len(str.s) > 0) {
			strobj.left(str.s, strobj.len(str.s)-1) // result should look like [n
        		strobj.right(str.s, 1)
        		sscanf( str.s, "%d", &secIndex )
        		$&2 = secIndex
		} else {
			return 1
		}
$&2=secIndex
		return 0
}


/*!
 * Given some points on a targeted cell, randomly place synapses and generate their spike trains
 *
 * $1 gid
 * $2 lambda
 * $3 weight
 * $4 number of synapses
 * $o5 synapseType as String or nil if should use default (ExpSyn)  should this be the last arg so it can actually be dropped in default case?
 * $6 delay from start of simulation to when simulation starts
 * $7 duration of stimulus
 * $o8 TPointList with apical points
 * $o9 TPointList with basal points
 */
proc distributePoissonSynapses() { local nCreated, nNeeded, iteration, baseSeed, sectionIndex, lambda, weight, del, dur \
    localobj ran1, ran2, apicalPoints, basalPoints, activeSubset, synapseType, nc, fih, nil
    strdef tstr
    
    apicalPoints = $o8
    basalPoints = $o9
    baseSeed = $1 * 10000 + poissonStimCount * 10000 //-> should baseSeed be an arg so that it doesn't need knowledge of # of previous npoisson stims?
    iteration = 0
    nCreated = 0
    lambda = $2
    weight = $3
    del = $6
    dur = $7
    
    //determine now if the synapseType is given or we should use the default
    if( object_id($o5,1) < 0 ) {
        synapseType = new String("ExpSyn")
    } else {
        synapseType = $o5
    }
    
    nNeeded  =  int($4)
    while ( nCreated < nNeeded ) {
    
        //count the iterations and use that to offset the seed
        iteration = iteration + 1
        
        ran2 = new Random(baseSeed + iteration)
        ran2.MCellRan4(baseSeed + iteration)
        ran2.discunif(0,1)
        
        ran1 = new Random(baseSeed + iteration)
        ran1.MCellRan4(baseSeed + iteration)
        
        //first choose to target apical of basal sections
        if(ran2.repick()) {
            activeSubset = basalPoints
        } else {
            activeSubset = apicalPoints
        }
        
        if( activeSubset.count() == 0 ) { continue }
        
        ran1.discunif( 0, activeSubset.count()-1 )
        sectionIndex = ran1.repick()
        
        //do we have random access to TPointList SectionRef members?  how should such a utility function look/behave?
        if( !activeSubset.sclst.o(sectionIndex).exists() ) {  //section not on this cpu
            nCreated = nCreated + 1  //assume another split piece handles it instead
            continue
        }
        
        //the section is on this cpu, so create the synapse and fill the spike train
        activeSubset.access_(sectionIndex)
        sprint(tstr,"stimHelper = new %s(0.5)", synapseType.s )
        execute1(tstr, this)
        
        //why do we register an init handler if we are just going to call the function anyways?
        // do we end up with twice the events?
        nc = new NetCon( nil, stimHelper,10,1,weight )
        sprint(tstr,"FillSpikeTrain(%s,%f,%f,%f,%d)", nc, lambda, del, dur, baseSeed+iteration )
        fih = new FInitializeHandler(tstr, this)
        execute1(tstr, this)
        
        //keep variables so they don't get deleted
        poissonNetconList.append(nc)
        poissonSynList.append(stimHelper)
        handleList.append(fih)
        
        nCreated = nCreated + 1
    }
}

//-----------------------------------------------------------------------------------------------

/*!
 * This function creates spike events distributed as the intervals between events in a poisson distribution.
 * It populates a vector with randomly generated time values and assigns those to the given netcon.
 *
 * @param $o1 Netcon Object
 * @param $2 mean firing rate.
 * @param $3 Delay
 * @param $4 TimeDuration
 * @param $5 seed
 */
proc FillSpikeTrain() { local i,tmpt, time, index, SpikeNeeded, nSpikeNeeded, SpikeDiff localobj ran, tVec, ran2
    //print "Seed = ", $5
    tVec    =  new Vector()
    ran     =  new Random()   
    ran.ACG($5) 
    //ran.MCellRan4()
    ran.negexp(1000/$2)
    //ran.negexp($2)
    time    = 0    
    SpikeNeeded = (($4 * $2)/1000)
    nSpikeNeeded = int (SpikeNeeded)
    if((SpikeNeeded - nSpikeNeeded) >= 0.5){
       nSpikeNeeded = nSpikeNeeded + 1
    }
   
    while (time < $4){
	tmpt = ran.repick()
        //time = time + ran.repick()
        if(tmpt+time > $4){
            break
        }
        time = time + tmpt
        tVec.append(time)
    }
    if(SpikeNeeded < 1)	  {
        time = 0 
    }

    for i =0, tVec.size-1 {
        $o1.event(tVec.x[i] + $3) 
    }
}

endtemplate StimulusManager
