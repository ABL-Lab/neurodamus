/*****************************************************************
    FileName    : StimulusManager.hoc
    Project     : Blue Brain Project
    Place       : EPFL, Lausanne Switzerland.
    Purpose     : Process Synapse connections Rules of a BlueConfig (if any) and then instantiate the synapses 
                  for a bluebrain sim
    Author      : 1. Jim King
                  2. Rajnish Ranjan
    Revision    : $Revision$ at: $Date$ by $Author$
****************************************************************/

{load_file("alib/TStim.hoc")}  //note that the TStim functions are used in a way where our naming schemes don't match 100%

begintemplate StimulusManager

//-----------------------------------------------------------------------------------------------
// Declare member variables
//-----------------------------------------------------------------------------------------------

objref stimList, targetManager, this

//! For use in poisson stims, when creating via the execute stmt, need to have class level object (not just local to function)
objref stimHelper, poissonNetconList, handleList, poissonSynList

//-----------------------------------------------------------------------------------------------
// public members
//-----------------------------------------------------------------------------------------------

public init, linear, interpret, FillSpikeTrain

//-----------------------------------------------------------------------------------------------
// Member function implementations
//-----------------------------------------------------------------------------------------------

/*!
 * Typical constructor, create empty list where stimulus are stored as they get generated, keep reference
 * to TargetManager for accessing Targets
 *
 * @param $o1 TargetManager
 */
proc init() {
    stimList = new List()
    targetManager = $o1
    
    //keep track of how many poisson stims we create so that the seeds can be offset (otherwise we would have same syns/spike trains in a given cell)
    poissonStimCount = 0
    poissonNetconList = new List()
    poissonSynList = new List()
    handleList = new List()
}

//-----------------------------------------------------------------------------------------------

/*!
 * For handling stimulus which has been parsed from a file - look at the parameters collected and
 * call the appropriate stimulus functions
 *
 * @param $s1 targetName - which target where stimulus should be injected
 * @param $o2 stim - map containing stimulus parameters
 * 
 * alternatively for Ruben's PFE
 * @param $o1 TPointList where stimulus will be injected
 * @param $o2 stim - map containing stimulus parameters
 * @param $3 gid of cell
 */
proc interpret() { local tempVal, del, dur, relamp, threshold  localobj stim, target, paramValue, paramVect, patternName, nil

    stim = $o2
    
    paramVect = new Vector()
    
    //mode should always be 'Current' - do we plan to support more modes?
    paramValue = stim.get( "Mode" )
    if( strcmp( paramValue.s, "Current" ) != 0 ) {
        print "Invalid Mode - ", paramValue.s
        return
    }
    
    //all will have Delay and Duration, so parse immediately
    del = stim.valueOf( "Delay" )
    dur = stim.valueOf( "Duration" )
    
    //more specific parameters based on pattern
    patternName = stim.get( "Pattern" )
    
    // Ruben's pfe chunk
    //
    // check for TPointList argument
    if( argtype(1) == 1 ) {
        if( strcmp( patternName.s, "SquarePulse" ) == 0 ) {
            relamp = stim.valueOf( "relAmp" )
            threshold = targetManager.getCell($3).getThreshold()
            //linear( target, relamp * threshold, relamp * threshold, del, dur )
            squarepulse( $o1, relamp * threshold, del, dur )
        }
    // end of Ruben's pfe chunk
    //
    // check for target name argument
    } else if( argtype(1) == 2 ) {
        if( strcmp( patternName.s, "Linear" ) == 0 ) {
            paramVect.append( stim.valueOf("AmpStart") )
            
            //optional option - AmpEnd.  If not there, use same value as AmpStart
            if( stim.get( "AmpEnd" ) != nil ) {
                paramVect.append( stim.valueOf("AmpEnd") )
            } else {
                paramVect.append( paramVect.x[paramVect.count()-1] )
            }
            
            linear( $s1, paramVect.x[0], paramVect.x[1], del, dur )
        } else if ( strcmp( patternName.s, "Pulse" ) == 0 ) {
            //looking at bglib, it expects potentially multiple delay/duration pairs (and an AmpEnd)
            // TODO: rename bglib's stimulus pattern names to be inline with TStim, creating 'train' as replacement for bglib's 'pulse'
            
            paramVect.append( stim.valueOf( "AmpStart" ) )
            paramVect.append( stim.valueOf( "Frequency" ) )
            paramVect.append( stim.valueOf( "Width" ) )
            
            //optional argument - Offset; default = 0.
            // TODO: re-evaluate offset for Pulse stimulus and debug because it looks like it might not be multisplit safe
            if( stim.get( "Offset" ) != nil ) {
                paramVect.append( stim.valueOf( "Offset" ) )
            } else {
                paramVect.append( 0 )
            }
            
            train( $s1, paramVect.x[0], paramVect.x[1], paramVect.x[2], paramVect.x[3], del, dur )
            //linear( $s1, paramVect.x[0], paramVect.x[0], del, dur )
        } else if( strcmp( patternName.s, "NPoisson" ) == 0 ) {
            paramVect.append( stim.valueOf( "Lambda" ) )
            paramVect.append( stim.valueOf( "Weight" ) )
            paramVect.append( stim.valueOf( "NumOfSynapses" ) )
            
            //Note: SynapseType is optional and will return nil (handled by npoisson function)
            //Note: requires special Target handling, so just pass targetName through
            npoisson( $s1, paramVect.x[0], paramVect.x[1], paramVect.x[2], stim.get( "SynapseType" ), del, dur )
        } else if( strcmp( patternName.s, "SubThreshold" ) == 0 ) {
            subthreshold( $s1, stim.valueOf( "PercentLess" ), del, dur )
        }
    }
}

//-----------------------------------------------------------------------------------------------

/*!
 * Injects a squarepulse stimulus into a cell. Takes a TPointList, not a target, as first argument
 *
 * @param $o1 TPointList of points where iclamps will be placed
 * @param $2 amp amplitude of the current injected (nA)
 * @param $3 delay from start of simulation to when current is injected (ms)
 * @param $4 duration of stimulus (ms)
 */
proc squarepulse() { local cellIndex, x, amp, del, dur  localobj pts, tstim
    
    amp = $2
    del = $3
    dur = $4

    //since there are no random elements, we can just evaluate the pointlist and proceed as normal
    pts = $o1
    
    for pts.each_point(&x) {
        
        tstim = new TStim(x)
        
        tstim.pulse( del, dur, amp)
        stimList.append( tstim )
    }
}

//-----------------------------------------------------------------------------------------------

/**
 * Injects a pulse stimulus into the targeted locations scaled to some percentage of that cell's threshold
 * current (the current needed to cause 1 AP)
 *
 * @param $s1 Target name which should receive the stimulus
 * @param $2 Percent less than full threshold current (e.g. val of 5 indicates that 95% of threshold is to be injected
 * @param $3 del
 * @param $4 dur
 */
proc subthreshold() { local cellIndex, x  localobj pts, cellList, tstim

    pts = targetManager.getPointList($s1)
    cellList = targetManager.getCells($s1)
    
    for cellIndex=0, pts.count()-1 {
        for pts.o(cellIndex).each_point(&x) {
            tstim = new TStim(x)
            
            tstim.pulse( $3, $4, cellList.o(cellIndex).getCCell().getThreshold()*(100-$2) )
            stimList.append(tstim)
        }
    }
}

//-----------------------------------------------------------------------------------------------

/*!
 * Injects a train stimulus into cells wih regular frequency.
 *
 * @param $s1 Name of Target where stims will be placed
 * @param $2 amp
 * @param $3 frequency
 * @param $4 width
 * @param $5 offset std dev
 * @param $6 del
 * @param $7 dur
 */
proc train() { local cellIndex, x, offset  localobj pts, tstim, jitter

    pts = targetManager.getPointList($s1)
    
    offset = 0
    for cellIndex=0, pts.count()-1 {        
        if( $5 != 0 ) {
            jitter = new Random( pts.o(cellIndex).gid )
            jitter.normal(0,$5)
        }
        
        for pts.o(cellIndex).each_point(&x) {
            tstim = new TStim(x)
            
            if( $5 != 0 ) {
                offset = jitter.repick()
                print "offset of ", offset
            }
            
            tstim.train( $6+offset, $7+offset, $2, $3, $4 )
            
            stimList.append(tstim)
        }
    }
}

//-----------------------------------------------------------------------------------------------

/*!
 * Injects a square pulse into a cell.  Note that if the starting and ending amplitude are the same,
 * a simple 
 *
 * @param $s1 Name of Target where iclamps will be placed
 * @param $2 ampStart Starting amplitude of the current injected (nA)
 * @param $3 ampEnd Final amplitude of the current when done injecting (nA)
 * @param $4 delay from start of simulation to when current is injected (ms)
 * @param $5 duration of stimulus (ms)
 */
proc linear() { local cellIndex, x, ampStart, ampEnd, del, dur  localobj pts, tstim
    
    ampStart = $2
    ampEnd = $3
    del = $4
    dur = $5

    //since there are no random elements, we can just evaluate the pointlist and proceed as normal
    pts = targetManager.getPointList($s1)
    
    for cellIndex=0, pts.count()-1 {
        for pts.o(cellIndex).each_point(&x) {
            
            tstim = new TStim(x)
            
            if( ampStart == ampEnd ) {
                tstim.pulse( del, dur, ampStart )
            } else {
                tstim.ramp( 0, del, ampStart, ampEnd, dur, 0, 0 )
            }
            
            stimList.append( tstim )
        }
    }
}

//-----------------------------------------------------------------------------------------------

/*!
 * Apply a poisson stimulus over n artificial synapses distributed randomly on a cell's basal and apical sections
 * 
 * @param $s1 TargetName
 * @param $2 lambda
 * @param $3 weight
 * @param $4 number of synapses
 * @param $o5 synapseType as String or nil if should use default (ExpSyn)
 * @param $6 delay from start of simulation to when stimulus starts (ms)
 * @param $7 duration of stimulus (ms)
 */
proc npoisson() { local cellIndex  localobj apicalPoints, basalPoints, gids
    
    //The synapses generated should only go on the apical or basal sections of any target cells
    // difficulty for doing exactly same thing as old bglib: that could operate easily on the section
    // of a cell, but now we work with compartment points only(?)  If so, random selection won't be the same
    // maybe the utility function of targetManager can return only the middle of all sections?
    // e.g Target section helper
    //     {
    //         base_target apic  //note that base_target must be a cell target, if section target, that is fine
    //         base_target dend
    //     }
    
    // open for interpretation - should I get the target, check they type and take action based on that?
    //  or should I send two requests to the targetManager asking for the apic & basal sections, letting
    //  the manager do checks and balances
    gids = targetManager.gids( $s1 )
    apicalPoints = targetManager.getApicalSections( $s1 )
    basalPoints = targetManager.getBasalSections( $s1 )
    
    //for each gid/TPointList - place synapses randomly and supply a spike train
    for cellIndex=0, gids.size()-1 {
        
        //so all cells should be represented and have the same point count regardless of splitting        
        distributePoissonSynapses( gids.x[cellIndex], $2, $3, $4, $o5, $6, $7, apicalPoints.o(cellIndex), basalPoints.o(cellIndex) )
    }
    
    poissonStimCount = poissonStimCount + 1
}

//-----------------------------------------------------------------------------------------------

/*!
 * Given some points on a targeted cell, randomly place synapses and generate their spike trains
 *
 * $1 gid
 * $2 lambda
 * $3 weight
 * $4 number of synapses
 * $o5 synapseType as String or nil if should use default (ExpSyn)  should this be the last arg so it can actually be dropped in default case?
 * $6 delay from start of simulation to when simulation starts
 * $7 duration of stimulus
 * $o8 TPointList with apical points
 * $o9 TPointList with basal points
 */
proc distributePoissonSynapses() { local nCreated, nNeeded, iteration, baseSeed, sectionIndex, lambda, weight, del, dur \
    localobj ran1, ran2, apicalPoints, basalPoints, activeSubset, synapseType, nc, fih, nil
    strdef tstr
    
    apicalPoints = $o8
    basalPoints = $o9
    baseSeed = $1 * 10000 + poissonStimCount * 10000 //-> should baseSeed be an arg so that it doesn't need knowledge of # of previous npoisson stims?
    iteration = 0
    nCreated = 0
    lambda = $2
    weight = $3
    del = $6
    dur = $7
    
    //determine now if the synapseType is given or we should use the default
    if( object_id($o5,1) < 0 ) {
        synapseType = new String("ExpSyn")
    } else {
        synapseType = $o5
    }
    
    nNeeded  =  int($4)
    while ( nCreated < nNeeded ) {
    
        //count the iterations and use that to offset the seed
        iteration = iteration + 1
        
	    ran2 = new Random(baseSeed + iteration)
        ran2.MCellRan4(baseSeed + iteration)
	    ran2.discunif(0,1)
        
	    ran1 = new Random(baseSeed + iteration)
        ran1.MCellRan4(baseSeed + iteration)
        
        //first choose to target apical of basal sections
	    if(ran2.repick()) {
            activeSubset = basalPoints
        } else {
            activeSubset = apicalPoints
        }
        
        if( activeSubset.count() == 0 ) { continue }
        
        ran1.discunif( 0, activeSubset.count()-1 )
        sectionIndex = ran1.repick()
        
        //do we have random access to TPointList SectionRef members?  how should such a utility function look/behave?
        if( !activeSubset.sclst.o(sectionIndex).exists() ) {  //section not on this cpu
            nCreated = nCreated + 1  //assume another split piece handles it instead
            continue
        }
        
        //the section is on this cpu, so create the synapse and fill the spike train
        activeSubset.access_(sectionIndex)
        sprint(tstr,"stimHelper = new %s(0.5)", synapseType.s )
        execute1(tstr, this)
        
        //why do we register an init handler if we are just going to call the function anyways?
        // do we end up with twice the events?
        nc = new NetCon( nil, stimHelper,10,1,weight )
        sprint(tstr,"FillSpikeTrain(%s,%f,%f,%f,%d)", nc, lambda, del, dur, baseSeed+iteration )
        fih = new FInitializeHandler(tstr, this)
        execute1(tstr, this)
        
        //keep variables so they don't get deleted
        poissonNetconList.append(nc)
        poissonSynList.append(stimHelper)
        handleList.append(fih)
        
        nCreated = nCreated + 1
    }
}

//-----------------------------------------------------------------------------------------------

/*!
 * This function creates spike events distributed as the intervals between events in a poisson distribution.
 * It populates a vector with randomly generated time values and assigns those to the given netcon.
 *
 * @param $o1 Netcon Object
 * @param $2 mean firing rate.
 * @param $3 Delay
 * @param $4 TimeDuration
 * @param $5 seed
 */
proc FillSpikeTrain() { local i,tmpt, time, index, SpikeNeeded, nSpikeNeeded, SpikeDiff localobj ran, tVec, ran2
    //print "Seed = ", $5
    tVec    =  new Vector()
    ran     =  new Random()   
    ran.ACG($5) 
    //ran.MCellRan4()
    ran.negexp(1000/$2)
    //ran.negexp($2)
    time    = 0    
    SpikeNeeded = (($4 * $2)/1000)
    nSpikeNeeded = int (SpikeNeeded)
    if((SpikeNeeded - nSpikeNeeded) >= 0.5){
       nSpikeNeeded = nSpikeNeeded + 1
    }
   
    while (time < $4){
	tmpt = ran.repick()
        //time = time + ran.repick()
        if(tmpt+time > $4){
            break
        }
        time = time + tmpt
        tVec.append(time)
    }
    if(SpikeNeeded < 1)	  {
        time = 0 
    }

    for i =0, tVec.size-1 {
        $o1.event(tVec.x[i] + $3) 
    }
}

endtemplate StimulusManager
