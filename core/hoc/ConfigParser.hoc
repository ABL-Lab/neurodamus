/*****************************************************************
    FileName    : ConfigParser.hoc
    Project     : Blue Brain Project
    Place       : EPFL, Lausanne Switzerland.
    Purpose     : The ConfigParser will handle reading BlueConfig files and make the information available
                  to other modules.  Whether the data read from the file should be stored in objects defined
                  in other files may be revised later.  For now, store everything in generic "map" class built
                  from basic implementation
    Author      : 1. James King
                  2. Rajnish Ranjan
    Revision    : $Revision$ at: $Date$ by $Author$
****************************************************************/

{load_file("nrngui.hoc")}
{load_file("Map.hoc")}

//------------------------------------------------------------------------------------------------------------
//------------------------------------------------------------------------------------------------------------
//------------------------------------------------------------------------------------------------------------

/*!
 * For a simple quick version, just have "map" objects that link up to reports, stims, etc.  These in turn
 * contain maps for the actual contents of a given block
 */
begintemplate ConfigParser
    //TODO: make a better encapsulated version

//------------------------------------------------------------------------------------------------------------
// Member fields
//------------------------------------------------------------------------------------------------------------

objref parsedRun, parsedReports, parsedStimuli, parsedInjects, parsedConnects, parsedElectrodes, strUtil

//------------------------------------------------------------------------------------------------------------
// Public accessible
//------------------------------------------------------------------------------------------------------------

public init, open, parsedRun, parsedReports, parsedStimuli, parsedInjects, parsedConnects, parsedElectrodes

//------------------------------------------------------------------------------------------------------------
// Member function implementations
//------------------------------------------------------------------------------------------------------------

proc init() {
    strUtil = new StringFunctions()
    
    // note that since there should only be one Run object, we create nothing now.
    parsedReports = new Map()
    parsedStimuli = new Map()
    parsedInjects = new Map()
    parsedConnects = new Map()
    parsedElectrodes = new Map()
}

//------------------------------------------------------------------------------------------------------------

/*!
 * Read the specified Config File, populating basic maps with the data read for now.
 *
 * @param $s1 Name of file to open and parse
 */
proc open() { local commentCheck  localobj configIn, rawline, strtemp, sectionName, sectionType, tempBlock
    
    configIn = new File()
    configIn.ropen( $s1 )
    
    if( configIn.isopen == 0 ) {
        printf( "Error: Could not open BlueConfig file '%s'\n", $s1 )
        quit()
    }
    
    //read line by line, branch off when encountering major block type: run, stimulus, report, stimulusinject, connect
    rawline = new String()
    strtemp = new String()
    sectionType = new String()
    sectionName = new String()
    
    while( configIn.gets(rawline.s) >= 0 ) {
        if( strcmp( rawline.s, "\n" ) == 0 ) {
        
        } else if( isCommented( rawline.s ) ) {
        } else {
            //non-comment line, there should be a name along with the yet to be determined section type
            sectionType.s = ""
            sscanf( rawline.s, "%s%s", sectionType.s, sectionName.s )
            
            //next line is open brace, so grab it now
            configIn.gets(strtemp.s)
            
            if( strcmp( sectionType.s, "Run" ) == 0 ) {
                parseRun( configIn )
            } else if ( strcmp( sectionType.s, "Report" ) == 0 ) {
                //print sectionName.s
                //parseReport( configIn, sectionName )
                tempBlock = parseBlock( configIn )
                parsedReports.put( sectionName, tempBlock )
            } else if ( strcmp( sectionType.s, "Stimulus" ) == 0 ) {
                parseStimulus( configIn, sectionName )
            } else if ( strcmp( sectionType.s, "StimulusInject" ) == 0 ) {
                parseStimulusInject( configIn, sectionName )
            } else if ( strcmp( sectionType.s, "Connection" ) == 0 ) {
                tempBlock = parseBlock( configIn )
                parsedConnects.put( sectionName, tempBlock )
            } else if ( strcmp( sectionType.s, "Electrode" ) == 0 ){
            	tempBlock = parseBlock( configIn )            			
            	parsedElectrodes.put( sectionName, tempBlock )
            }
        }
    }
    
    configIn.close
}

//------------------------------------------------------------------------------------------------------------

/*!
 * @param $o1 configIn
 */
proc parseRun() { localobj rawline, configIn, fieldName, fieldValue

    //user is only allowed to declare one Run section in the config file
    if( object_id(parsedRun) != 0 )  {
        printf( "Error: multiple Run objects declared in config file\n" )
        quit()
    }
    
    rawline = new String()
    configIn = $o1
    
    parsedRun = new Map()
    
    while( configIn.gets(rawline.s) >= 0 ) {
        //check if close brace to terminate section
        if( isTerminated( rawline.s ) ) {
            return
        }
    
        if( !isCommented( rawline.s )) {
            //we only expect string pairs for run objects, so keep it simple for now
            fieldName = new String()
            fieldValue = new String()

            sscanf( rawline.s, "%s%s", fieldName.s, fieldValue.s )
            
            parsedRun.put( fieldName, fieldValue )
        }
    }
}

//------------------------------------------------------------------------------------------------------------

/*!
 * @param $o1 File getting parsed
 */
obfunc parseBlock() { local ret  localobj pendingBlock, rawline, configIn, fieldName, fieldValue
    strdef wscheck
    
    rawline = new String()
    configIn = $o1
    
    pendingBlock = new Map()
    
    while( configIn.gets(rawline.s) >= 0 ) {
    
        //check if close brace to terminate section
        if( isTerminated( rawline.s ) ) {
            return pendingBlock
        }
        
        if( !isCommented( rawline.s )) {
            
            //just grab the first string, then everything after that string
            fieldName = new String()
            fieldValue = new String()
            
            sscanf( rawline.s, "%s", fieldName.s )
            
            strUtil.tail( rawline.s, fieldName.s, fieldValue.s )
            
            //check for leading and trailing white space in fieldValue
            wscheck = fieldValue.s
            strUtil.left( wscheck, 1 )
            if( strcmp( wscheck, " " ) == 0 || strcmp( wscheck, "\t" ) == 0 ) {
                ret = strUtil.tail( fieldValue.s, "[ \t]+", fieldValue.s ) //strip leading white space
            }
            
            wscheck = fieldValue.s
            strUtil.right( wscheck, strUtil.len(wscheck)-1 )
            while( strcmp( wscheck, " " ) == 0 || strcmp( wscheck, "\t" ) == 0 || strcmp( wscheck, "\n" ) == 0 ) {
                strUtil.left( fieldValue.s, strUtil.len(fieldValue.s)-1 )
                wscheck = fieldValue.s
                strUtil.right( wscheck, strUtil.len(wscheck)-1 )
            }
            
            //add  to the map
            pendingBlock.put( fieldName, fieldValue )
        }
    }
}

//------------------------------------------------------------------------------------------------------------

/*!
 * @param $o1 File getting parsed
 * @param $o2 Stimulus name - String containing the name
 */
proc parseReport() { localobj pendingReport, rawline, configIn, fieldName, fieldValue

    rawline = new String()
    configIn = $o1
    
    pendingReport = new Map()
    
    while( configIn.gets(rawline.s) >= 0 ) {
    
        //check if close brace to terminate section
        if( isTerminated( rawline.s ) ) {
            parsedReports.put( $o2, pendingReport )
            return
        }
    
        if( !isCommented( rawline.s )) {
            
            //we only expect string pairs for stimulus objects, so keep it simple for now
            fieldName = new String()
            fieldValue = new String()

            sscanf( rawline.s, "%s%s", fieldName.s, fieldValue.s )
            
            pendingReport.put( fieldName, fieldValue )
        }
    }
}

//------------------------------------------------------------------------------------------------------------

/*!
 * @param $o1 File getting parsed
 * @param $o2 Stimulus name - String containing the name
 */
proc parseStimulus() { localobj pendingStim, rawline, configIn, fieldName, fieldValue

    rawline = new String()
    configIn = $o1
    
    pendingStim = new Map()
    
    while( configIn.gets(rawline.s) >= 0 ) {
    
        //check if close brace to terminate section
        if( isTerminated( rawline.s ) ) {
            parsedStimuli.put( $o2, pendingStim )
            return
        }
    
        if( !isCommented( rawline.s )) {
            
            //we only expect string pairs for stimulus objects, so keep it simple for now
            fieldName = new String()
            fieldValue = new String()

            sscanf( rawline.s, "%s%s", fieldName.s, fieldValue.s )
            
            pendingStim.put( fieldName, fieldValue )
        }
    }
}

//------------------------------------------------------------------------------------------------------------

/*!
 * @param $o1 File getting parsed
 * @param $o2 Stimulus Inject name - String containing the name
 */
proc parseStimulusInject() { localobj pendingInject, rawline, configIn, fieldName, fieldValue

    rawline = new String()
    configIn = $o1
    
    pendingInject = new Map()
    
    while( configIn.gets(rawline.s) >= 0 ) {
    
        //check if close brace to terminate section
        if( isTerminated( rawline.s ) ) {
            parsedInjects.put( $o2, pendingInject )
            return
        }
    
        if( !isCommented( rawline.s )) {
            //we only expect string pairs for stimulus objects, so keep it simple for now
            fieldName = new String()
            fieldValue = new String()

            sscanf( rawline.s, "%s%s", fieldName.s, fieldValue.s )
            pendingInject.put( fieldName, fieldValue )
        }
    }
}

//------------------------------------------------------------------------------------------------------------

/*!
 * @param $s1 Line to check for if it is commented or not
 * @return 1 if the line is commented (first non-ws character is a '#') or 0 if not commented
 */
func isCommented() {
    strdef temp
    
    sscanf( $s1, "%s", temp )
    
    //verify first non-ws charater is not '#'; otherwise, ignore whole line as comment
    if( strUtil.substr( temp, "#" ) != 0 ) {
        return 0
    } else {
        return 1
    }
    
}

//------------------------------------------------------------------------------------------------------------

/*!
 * @param $s1 Line to check for if terminating close brace is present
 * @return 1 if the line contains closing brace '}' to terminate section
 */
func isTerminated() {
    strdef temp
    
    sscanf( $s1, "%s", temp )
    
    if( strcmp( temp, "}" ) != 0 ) {
        return 0
    } else {
        return 1
    }
}

endtemplate ConfigParser
