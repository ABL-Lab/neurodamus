/*****************************************************************
    FileName    : ConfigParser.hoc
    Project     : Blue Brain Project
    Place       : EPFL, Lausanne Switzerland.
    Purpose     : The ConfigParser will handle reading BlueConfig files and make the information available
                  to other modules.  Whether the data read from the file should be stored in objects defined
                  in other files may be revised later.  For now, store everything in generic "map" class built
                  from basic implementation
    Author      : 1. James King
                  2. Rajnish Ranjan
    Revision    : $Revision:  $ at: $Date:  $ by $Author: $
****************************************************************/

{load_file("nrngui.hoc")}

/*!
 * Generic associative container to allow field names to be mapped to values (stored in objects)
 * for simplicity, this is not using any sorting or binary searching.
 */
begintemplate Map

//------------------------------------------------------------------------------------------------------------
// Member fields
//------------------------------------------------------------------------------------------------------------

objref stringList, valueList

//------------------------------------------------------------------------------------------------------------
// Public accessible
//------------------------------------------------------------------------------------------------------------

public init, get, put

//------------------------------------------------------------------------------------------------------------
// Member function implementations
//------------------------------------------------------------------------------------------------------------

proc init() {
    stringList = new List()
    valueList = new List()
}

//------------------------------------------------------------------------------------------------------------

/*!
 * Retrieve value associated with a given name
 *
 * @param $s1/$o1 name of object to find
 * @return value of object found or NULLobject if no name found
 */
obfunc get() { local mapIndex localobj nil
    //TODO: if we upgrade: objects should be stored sorted and then find via binary search
    
    strdef searchName
    if( argtype(1) == 1 ) { //extract string
        searchName = $o1.s
    } else {
        searchName = $s1
    }
    
    print "look for ", searchName
    
    //iterate over list until we find a name that matches
    for mapIndex=0, stringList.count()-1 {
        print mapIndex, " ", stringList.o(mapIndex).s
        if( strcmp( stringList.o(mapIndex).s, searchName ) == 0 ) {
            print "    found at index ", mapIndex, "!"
            return valueList.o(mapIndex)
        }
    }
    
    return nil
}

//------------------------------------------------------------------------------------------------------------

/*!
 * Add new name/value pair to map
 *
 * @param $o1/$s1 Name used to identify pair
 * @param $o2 Object containing value to associate with given name
 */
proc put() { localobj wrapString
    //TODO: if we upgrade: check for duplicates and store new objects in lexographical order
    
    if( argtype(1) == 2 ) {  //must wrap string in object
        wrapString = new String($s1)
        stringList.append( wrapString )
    } else {  
        stringList.append( $o1 ) //assume object is String
    }
    
    valueList.append( $o2 )
}

endtemplate Map

//------------------------------------------------------------------------------------------------------------
//------------------------------------------------------------------------------------------------------------
//------------------------------------------------------------------------------------------------------------

/*!
 * For a simple quick version, just have "map" objects that link up to reports, stims, etc.  These in turn
 * contain maps for the actual contents of a given block
 */
begintemplate ConfigParser
    //TODO: make a better encapsulated version

//------------------------------------------------------------------------------------------------------------
// Member fields
//------------------------------------------------------------------------------------------------------------

objref parsedRun, parsedReports, parsedStimuli, parsedInjects, parsedConnects, strUtil

//------------------------------------------------------------------------------------------------------------
// Public accessible
//------------------------------------------------------------------------------------------------------------

public init, open, parsedRun, parsedReports, parsedStimuli, parsedInjects, parsedConnects

//------------------------------------------------------------------------------------------------------------
// Member function implementations
//------------------------------------------------------------------------------------------------------------

proc init() {
    strUtil = new StringFunctions()
    // note that since there should only be one Run object, we create nothing now.
    parsedReports = new Map()
    parsedStimuli = new Map()
    parsedInjects = new Map()
    parsedConnects = new Map()
}

//------------------------------------------------------------------------------------------------------------

/*!
 * Read the specified Config File, populating basic maps with the data read for now.
 *
 * @param $s1 Name of file to open and parse
 */
proc open() { local commentCheck  localobj configIn, rawline, strtemp, sectionName, sectionType
    
    configIn = new File()
    configIn.ropen( $s1 )
    
    if( configIn.isopen == 0 ) {
        printf( "Error: Could not open BlueConfig file '%s'\n", $s1 )
        quit()
    }
    
    //read line by line, branch off when encountering major block type: run, stimulus, report, stimulusinject, connect
    rawline = new String()
    strtemp = new String()
    sectionType = new String()
    sectionName = new String()
    
    while( configIn.gets(rawline.s) >= 0 ) {
        if( strcmp( rawline.s, "\n" ) == 0 ) {
        
        } else if( isCommented( rawline.s ) ) {
        } else {
            //non-comment line, there should be a name along with the yet to be determined section type
            sscanf( rawline.s, "%s%s", sectionType.s, sectionName.s )
            
            //next line is open brace, so grab it now
            configIn.gets(strtemp.s)
            
            if( strcmp( sectionType.s, "Run" ) == 0 ) {
                parseRun( configIn )
            } else if ( strcmp( sectionType.s, "Report" ) == 0 ) {
            } else if ( strcmp( sectionType.s, "Stimulus" ) == 0 ) {
            } else if ( strcmp( sectionType.s, "StimulusInject" ) == 0 ) {
            } else if ( strcmp( sectionType.s, "Connection" ) == 0 ) {
            }
        }
        
        //Note that there is nothing for non-Run sections.  That's okay, we'll implement them as needed
    }
    
    configIn.close
}

//------------------------------------------------------------------------------------------------------------

/*!
 * @param $o1 configIn
 */
proc parseRun() { localobj rawline, configIn, fieldName, fieldValue

    //user is only allowed to declare one Run section in the config file
    if( object_id(parsedRun) != 0 )  {
        printf( "Error: multiple Run objects declared in config file\n" )
        quit()
    }
    
    rawline = new String()
    configIn = $o1
    
    parsedRun = new Map()
    
    while( configIn.gets(rawline.s) >= 0 ) {
        //check if close brace to terminate section
        if( isTerminated( rawline.s ) ) {
            return
        }
    
        if( !isCommented( rawline.s )) {
            //we only expect string pairs for run objects, so keep it simple for now
            fieldName = new String()
            fieldValue = new String()

            sscanf( rawline.s, "%s%s", fieldName.s, fieldValue.s )
            
            parsedRun.put( fieldName, fieldValue )
        }
    }
}

//------------------------------------------------------------------------------------------------------------

/*!
 * @param $s1 Line to check for if it is commented or not
 * @return 1 if the line is commented (first non-ws character is a '#') or 0 if not commented
 */
func isCommented() {
    strdef temp
    
    sscanf( $s1, "%s", temp )
    
    //verify first non-ws charater is not '#'; otherwise, ignore whole line as comment
    if( strUtil.substr( temp, "#" ) != 0 ) {
        return 0
    } else {
        return 1
    }
    
}

//------------------------------------------------------------------------------------------------------------

/*!
 * @param $s1 Line to check for if terminating close brace is present
 * @return 1 if the line contains closing brace '}' to terminate section
 */
func isTerminated() {
    strdef temp
    
    sscanf( $s1, "%s", temp )
    
    if( strcmp( temp, "}" ) != 0 ) {
        return 0
    } else {
        return 1
    }
}

endtemplate ConfigParser
