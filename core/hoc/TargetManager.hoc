/*****************************************************************
    FileName    : TargetManager.hoc
    Project     : Blue Brain Project
    Place       : EPFL, Lausanne Switzerland.
    Purpose     : The TargetManager provides an entity to encapsulate the steps to get cell points for use in Stimulation or Reporting
                  This should make certain features of the simulation transparent such as load balancing and target file format
    Author      : 1. Jim King
    Revision    : $Revision:  $ at: $Date:  $ by $Author: $
****************************************************************/

//make sure we have some basic things loaded
{load_file( "nrngui.hoc" )}

//------------------------------------------------------------------------------------------
// Target Manager
//------------------------------------------------------------------------------------------

/**
 * Target Manager itself, providing the interface for the user to get cell points to use
 */
begintemplate TargetManager

{load_file("Target.hoc")}

objref targetList, loadBalanceInfo, pnm, cellList

//basics
public init

//public functions to be accessed from outside
public setLoadBalanceInfo

//private functions
public getTarget, setTargetList, pnm, getPointList

//------------------------------------------------------------------------------------------

proc init() { local lastgid, cellIndex  localobj cellObj, secList, pointList
    
    if( argtype(1) == 1 ) {
        targetList = $o1
        
        if( argtype(2) == 1 ) {
            //should have recevied pnm
            pnm = $o2
        }
    }
    nErrors = 0
}

//------------------------------------------------------------------------------------------

/*!
 * Assign a targetList (most likely created by a TargetParser) to this TargetManager
 *
 * @param $o1 Existing targetList this TargetManger should make a reference to.
 */
proc setTargetList() {
    targetList = $o1
}

//------------------------------------------------------------------------------------------

/*!
 * If this TargetManager is not being used for a bluebrain simulaion, the user must register
 * any cells so that the TargetManager can find them (under a bluebrain sim, the pnm object
 * or something wrapping it will be used)
 *
 * @param $o1 Reference to a cell object the user has created
 */
proc registerCell() {
    if( object_id(cellList) == 0 ) {
        cellList = new List()
    }
    
    //should I sort this list?  well, yes, but not now :P
    cellList.append( $o1 )
}

//------------------------------------------------------------------------------------------

/*!
 *  Helper function to aid debugging.  Print targets and info about them to stdout
 *  Required Inputs : 
 *  Logic           : For each target, print info about all targets to stdout
 */
proc printTargets() {
    //print names of targets found
    for targetIndex=0, targetList.count()-1 {
        print "Found target ", targetList.object(targetIndex).name
        print "\t All Cells: ", targetList.object(targetIndex).gidMembers.size()
        print "\t Local Cells: ", targetList.object(targetIndex).gids.size()
        print "\t Targets: ", targetList.object(targetIndex).subtargets.count()
        for subIndex=0, targetList.object(targetIndex).subtargets.count()-1 {
            print "\t\t", targetList.object(targetIndex).subtargets.o[subIndex].name
        }
    }
}

//------------------------------------------------------------------------------------------

/*!
 *  Public function which retrieve a target from the list and returns it to the caller
 *  Required Inputs : $s1 Name of target to find and retrieve
 *  Logic           : Use binary search to locate the target, throwing an error if the target
 *                    is not found
 */
obfunc getTarget() { local targetIndex  localobj targetUtil
    strdef errorMessage

    targetUtil = new TargetUtility()
    targetIndex = targetUtil.findTarget( $s1, targetList )
    if( targetIndex < 0 ) {  //not found, error
        print "Error: target ", $s1, " not found.  Attempting to terminate"
        sprint( errorMessage, "Error: target %s not found", $s1 )
        execerror( errorMessage )
    } else {
        return targetList.object(targetIndex)
    }    
}

//------------------------------------------------------------------------------------------

/*!
 * Retrieve TPointList for the requested item.  If a gid is passed, a TPointList is retrieved for the given gid; otherwise, 
 * a TargetName is expected and a List of TPointLists are retrieved for members of the Target which are local to the cpu
 *
 * @param $1 or $s1 gid of a cell registered with the TargetManager, or name of Target parsed from a target file
 * @return TPointList for single gid, List<TPointList> for Target
 */
obfunc getPointList() { localobj activeTarget
    
    //if cells were registered directly, use that cell list to get cell objects for addressing sections; otherwise,
    // we will use a pnm object (for now - maybe it will be wrapped in another object?)
    
    if( argtype(1) == 0 && object_id(cellList) ) {
        print "cellList implementation pending"
    } else if( argtype(1) == 2 && object_id(pnm) ) {
        
        activeTarget = getTarget($s1)
        return activeTarget.getPointList( pnm )
        
    } else {
        print "no cell list?  no pnm?  where am I supposed to get cell sections from?.  I'm leaving"
    }
}

//------------------------------------------------------------------------------------------

/*!
 *  If the simulation is using LoadBalancing, a reference to the object handling that
 *  component can be provided which will be used to check when cells may be local/off node
 *  
 *  Required Inputs : $o1 Load balancing info
 *  Logic           : Save the reference for use during target accessing operations
 */
func setLoadBalanceInfo() {
    loadBalanceInfo = $o1
    
    //once loadbalance info is know, can localize targets.
    for targetIndex=0, targetList.count()-1 {
        targetList.object(targetIndex).localize( loadBalanceInfo.getGidListForProcessor(), loadBalanceInfo )
    }
}

endtemplate TargetManager
