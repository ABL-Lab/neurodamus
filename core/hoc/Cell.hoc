{load_file("import3d.hoc")}

begintemplate Cell
public init, printInfo, AddMorphNL, getCCell, setCCell, geom_nsec, geom_nseg_lambda, geom_nseg_fixed, SetCellProperties, connect2target, delete_axon, insertChannel
public soma, dend, apic, axon, nSecAxonal, nSecAxonalOrig, segCounts, rnglist
public synlist, all, apical, basal, somatic, axonal, gid, nSecAll, nSecSoma, nSecApical, nSecBasal, clear, ASCIIrpt, HDF5rpt, APC
objref synlist, all, apical, basal, somatic, axonal, this, CCellRef, ASCIIrpt, HDF5rpt, APC, segCounts, rnglist

//! Used when computing nseg per section
external lambda_f

/*!
 * Constructor to create a Cell object usable in the bbp toolchain
 *
 * @param $1 gid [optional] Unique identifier for this cell if it to be used in a network
 * @param $s2 full path to morphology [optional] file to load in cell's geometric information
 */
proc init() {
    gid     = 0
    all     = new SectionList()
    somatic = new SectionList()
    basal   = new SectionList()
    apical  = new SectionList()
    axonal  = new SectionList()
    forall delete_section()
    if(numarg()>0) gid = $1
    if(numarg()>1){
        AddMorphNL($s2)
    }
    
    synlist = new List()
    rnglist = new List()
}
create soma[1], dend[1], apic[1], axon[1]

proc AddMorphNL(){ localobj nl, import
    forall delete_section()    
    nl = new Import3d_Neurolucida3()
    nl.quiet = 1
    nl.input($s1)
    import = new Import3d_GUI(nl, 0)
    import.instantiate(this)
    indexSections(import)
    geom_nsec()
}

proc delete_axon(){local nSec, D1, D2, dist, i1, i2, count
    count = 0
    nSec  = 0
    forsec axonal{nSec = nSec + 1}
    if(nSec ==0){ //No axon section present
        D1 = 1
        D2 = 1
    }else{
        access axon[0]
        i1 = v(0.0001) //hack needed for bglib 
        D1 = diam
        D2 = diam
        if(nSec >1){ //Only one axon section present
            access soma distance() //to calculate distance from soma
            forsec axonal{   // loop through all axon sections and check for 60um distance 
                if(count == 1){
                    i2 = v(0.0001) //hack needed for bglib
                }
                count = count + 1
                dist = distance(0.5)
                if(dist > 60){ //if section is longer than 60um then store diam and exit from look
                    D2 = diam
                    break
                }

            }
        }
    }
    forsec axonal{delete_section()}    
    execute1("create axon[2]\n", this)
    access axon[0] {
        L = 30
        diam = D1
        nseg = 1 + 2*int(L/40)
        all.append()
        axonal.append()
        v(0.0001) = i1
    }
    access axon[1] {
        L = 30
        diam = D2
        nseg = 1 + 2*int(L/40)
        all.append()
        axonal.append()
        v(0.0001) = i2   // !!!if this cell does not contain 2 sections then this is source of bug
    } 
    nSecAxonal = 2
    soma[0] connect axon[0](0), 1
    axon[0] connect axon[1](0), 1
}


proc SetCellProperties(){local Rm,v_init
        Rm = $1
        v_init = $2
        forall {
                insert pas
                Ra = 80
                g_pas=1/Rm
                e_pas=v_init
                cm = 1
        }
        
        //whenever the Cell properties (resistance esp.) change, recalculate how a section divides into segments
        //geom_nseg()  //for now, let the CCell do this after biophys is executed
}

/*!
 * Iterate over the section and compute how many sqgments should be allocate to each.  This number
 * is influenced by the mechanisms distributed, so this function should be called after assigning biophys
 */
proc geom_nseg_lambda() { local secIndex
    soma area(.5) // make sure diam reflects 3d points
    
    secIndex=0
    forsec all {
        nseg = int((L/(0.1*lambda_f(100))+.9)/2)*2 + 1
        
        segCounts.x[secIndex] = nseg
        secIndex = secIndex+1
    }
}

/*!
 * Iterate over the section and compute how many sqgments should be allocate to each.  This number
 * is influenced by the mechanisms distributed, so this function should be called after assigning biophys
 * @param $1 nseg length
 */
proc geom_nseg_fixed() { local secIndex
    soma area(.5) // make sure diam reflects 3d points
    secIndex=0
    forsec all {
        nseg = 1 + 2*int(L/$1)
        segCounts.x[secIndex] = nseg
        secIndex = secIndex+1
    }
}

/*!
 * Count up the number of sections. Additionally, assign as estimate to the nseg var of each section, but this
 * will most likely change after biophys are assigned and geom_nseg called
 */
proc geom_nsec() { local nSec
    nSec = 0
    forsec all {        
        nSec = nSec + 1        
    }
    nSecAll = nSec
    nSec = 0
    forsec somatic { nSec = nSec + 1}
    nSecSoma    =   nSec
    nSec = 0
    forsec apical { nSec = nSec + 1}
    nSecApical=     nSec
    nSec = 0
    forsec basal { nSec = nSec + 1}
    nSecBasal   =   nSec
    nSec = 0
    forsec axonal { nSec = nSec + 1}
    nSecAxonalOrig = nSecAxonal = nSec
    
    segCounts = new Vector()
    segCounts.resize(nSecAll)
    nSec=0
    forsec all {
        segCounts.x[nSec] = nseg
        nSec = nSec+1
    }
}

obfunc getCCell(){
    return CCellRef
}
proc setCCell(){
    CCellRef = $o1
}

//-----------------------------------------------------------------------------------------------

/*!
 * Assign section indices to the section voltage value.  This will be useful later for serializing 
 * the sections into an array.  Note, that once the simulation begins, the voltage values will revert to actual data again.
 *
 * @param $o1 Import3d_GUI object
 */
proc indexSections() { local index  localobj tmpString, s
    tmpString = new String()

    s = $o1.swc.sections
    for i=0, s.count()-1 {
        $o1.name( s.object(i), tmpString.s )
        sprint( tmpString.s, "%s.v(0.0001) = %d", tmpString.s, i )
        execute( tmpString.s, this )
    }
}

//-----------------------------------------------------------------------------------------------

/*!
 * When clearing the model, the circular reference between Cells and CCells must be broken so the 
 * entity watching reference counts can work.
 */
proc clear() { localobj nil
    CCellRef.CellRef = nil
    //CCellRef = nil
}

//-----------------------------------------------------------------------------------------------

/*!
 * @param $o1 NetCon source (can be nil)
 * @param $o2 Variable where generated NetCon will be placed
 */
proc connect2target() { //$o1 target point process, $o2 returned NetCon
  soma $o2 = new NetCon(&v(1), $o1)
  $o2.threshold = -30
}

proc insertChannel(){ localobj tmpString
    tmpString = new String()
    sprint(tmpString.s, "forsec %s  insert %s", $s1, $s2)
    execute(tmpString.s, this)
}

endtemplate Cell
